{
  "resolvedId": "D:/projects/nuxt/workix-nuxt-front/node_modules/vue-qrcode-reader/dist/vue-qrcode-reader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { defineComponent as Lt, ref as we, watch as We, onMounted as po, onUnmounted as mo, computed as Ut, openBlock as Ht, createElementBlock as Bt, createElementVNode as nt, normalizeStyle as vo, withDirectives as yo, vShow as go, renderSlot as Mr, withModifiers as at } from \"vue\";\nvar Ar = (r, o, i) => {\n  if (!o.has(r))\n    throw TypeError(\"Cannot \" + i);\n}, Cr = (r, o, i) => (Ar(r, o, \"read from private field\"), i ? i.call(r) : o.get(r)), wo = (r, o, i) => {\n  if (o.has(r))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  o instanceof WeakSet ? o.add(r) : o.set(r, i);\n}, bo = (r, o, i, c) => (Ar(r, o, \"write to private field\"), c ? c.call(r, i) : o.set(r, i), i);\nconst Dr = [\n  [\"aztec\", \"Aztec\"],\n  [\"code_128\", \"Code128\"],\n  [\"code_39\", \"Code39\"],\n  [\"code_93\", \"Code93\"],\n  [\"codabar\", \"Codabar\"],\n  [\"databar\", \"DataBar\"],\n  [\"databar_expanded\", \"DataBarExpanded\"],\n  [\"data_matrix\", \"DataMatrix\"],\n  [\"dx_film_edge\", \"DXFilmEdge\"],\n  [\"ean_13\", \"EAN-13\"],\n  [\"ean_8\", \"EAN-8\"],\n  [\"itf\", \"ITF\"],\n  [\"maxi_code\", \"MaxiCode\"],\n  [\"micro_qr_code\", \"MicroQRCode\"],\n  [\"pdf417\", \"PDF417\"],\n  [\"qr_code\", \"QRCode\"],\n  [\"rm_qr_code\", \"rMQRCode\"],\n  [\"upc_a\", \"UPC-A\"],\n  [\"upc_e\", \"UPC-E\"],\n  [\"linear_codes\", \"Linear-Codes\"],\n  [\"matrix_codes\", \"Matrix-Codes\"]\n], Co = [...Dr, [\"unknown\"]].map((r) => r[0]), it = new Map(\n  Dr\n);\nfunction $o(r) {\n  for (const [o, i] of it)\n    if (r === i)\n      return o;\n  return \"unknown\";\n}\nfunction _o(r) {\n  if (Rr(r))\n    return {\n      width: r.naturalWidth,\n      height: r.naturalHeight\n    };\n  if (xr(r))\n    return {\n      width: r.width.baseVal.value,\n      height: r.height.baseVal.value\n    };\n  if (kr(r))\n    return {\n      width: r.videoWidth,\n      height: r.videoHeight\n    };\n  if (Fr(r))\n    return {\n      width: r.width,\n      height: r.height\n    };\n  if (Wr(r))\n    return {\n      width: r.displayWidth,\n      height: r.displayHeight\n    };\n  if (Ir(r))\n    return {\n      width: r.width,\n      height: r.height\n    };\n  if (Ur(r))\n    return {\n      width: r.width,\n      height: r.height\n    };\n  throw new TypeError(\n    \"The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'.\"\n  );\n}\nfunction Rr(r) {\n  try {\n    return r instanceof HTMLImageElement;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction xr(r) {\n  try {\n    return r instanceof SVGImageElement;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction kr(r) {\n  try {\n    return r instanceof HTMLVideoElement;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction Ir(r) {\n  try {\n    return r instanceof HTMLCanvasElement;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction Fr(r) {\n  try {\n    return r instanceof ImageBitmap;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction Ur(r) {\n  try {\n    return r instanceof OffscreenCanvas;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction Wr(r) {\n  try {\n    return r instanceof VideoFrame;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction jr(r) {\n  try {\n    return r instanceof Blob;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction So(r) {\n  try {\n    return r instanceof ImageData;\n  } catch (o) {\n    return !1;\n  }\n}\nfunction Po(r, o) {\n  try {\n    const i = new OffscreenCanvas(r, o);\n    if (i.getContext(\"2d\") instanceof OffscreenCanvasRenderingContext2D)\n      return i;\n    throw void 0;\n  } catch (i) {\n    const c = document.createElement(\"canvas\");\n    return c.width = r, c.height = o, c;\n  }\n}\nasync function Lr(r) {\n  if (Rr(r) && !await Mo(r))\n    throw new DOMException(\n      \"Failed to load or decode HTMLImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (xr(r) && !await Ao(r))\n    throw new DOMException(\n      \"Failed to load or decode SVGImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (Wr(r) && Do(r))\n    throw new DOMException(\"VideoFrame is closed.\", \"InvalidStateError\");\n  if (kr(r) && (r.readyState === 0 || r.readyState === 1))\n    throw new DOMException(\"Invalid element or state.\", \"InvalidStateError\");\n  if (Fr(r) && xo(r))\n    throw new DOMException(\n      \"The image source is detached.\",\n      \"InvalidStateError\"\n    );\n  const { width: o, height: i } = _o(r);\n  if (o === 0 || i === 0)\n    return null;\n  const c = Po(o, i).getContext(\"2d\");\n  c.drawImage(r, 0, 0);\n  try {\n    return c.getImageData(0, 0, o, i);\n  } catch (d) {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function To(r) {\n  let o;\n  try {\n    if (globalThis.createImageBitmap)\n      o = await createImageBitmap(r);\n    else if (globalThis.Image) {\n      o = new Image();\n      let i = \"\";\n      try {\n        i = URL.createObjectURL(r), o.src = i, await o.decode();\n      } finally {\n        URL.revokeObjectURL(i);\n      }\n    } else\n      return r;\n  } catch (i) {\n    throw new DOMException(\n      \"Failed to load or decode Blob.\",\n      \"InvalidStateError\"\n    );\n  }\n  return await Lr(o);\n}\nfunction Eo(r) {\n  const { width: o, height: i } = r;\n  if (o === 0 || i === 0)\n    return null;\n  const c = r.getContext(\"2d\");\n  try {\n    return c.getImageData(0, 0, o, i);\n  } catch (d) {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function Oo(r) {\n  if (jr(r))\n    return await To(r);\n  if (So(r)) {\n    if (Ro(r))\n      throw new DOMException(\n        \"The image data has been detached.\",\n        \"InvalidStateError\"\n      );\n    return r;\n  }\n  return Ir(r) || Ur(r) ? Eo(r) : await Lr(r);\n}\nasync function Mo(r) {\n  try {\n    return await r.decode(), !0;\n  } catch (o) {\n    return !1;\n  }\n}\nasync function Ao(r) {\n  var o;\n  try {\n    return await ((o = r.decode) == null ? void 0 : o.call(r)), !0;\n  } catch (i) {\n    return !1;\n  }\n}\nfunction Do(r) {\n  return r.format === null;\n}\nfunction Ro(r) {\n  return r.data.buffer.byteLength === 0;\n}\nfunction xo(r) {\n  return r.width === 0 && r.height === 0;\n}\nfunction $r(r, o) {\n  return r instanceof DOMException ? new DOMException(`${o}: ${r.message}`, r.name) : r instanceof Error ? new r.constructor(`${o}: ${r.message}`) : new Error(`${o}: ${r}`);\n}\nconst _r = [\n  \"Aztec\",\n  \"Codabar\",\n  \"Code128\",\n  \"Code39\",\n  \"Code93\",\n  \"DataBar\",\n  \"DataBarExpanded\",\n  \"DataMatrix\",\n  \"DXFilmEdge\",\n  \"EAN-13\",\n  \"EAN-8\",\n  \"ITF\",\n  \"Linear-Codes\",\n  \"Matrix-Codes\",\n  \"MaxiCode\",\n  \"MicroQRCode\",\n  \"None\",\n  \"PDF417\",\n  \"QRCode\",\n  \"rMQRCode\",\n  \"UPC-A\",\n  \"UPC-E\"\n];\nfunction ko(r) {\n  return r.join(\"|\");\n}\nfunction Io(r) {\n  const o = Sr(r);\n  let i = 0, c = _r.length - 1;\n  for (; i <= c; ) {\n    const d = Math.floor((i + c) / 2), h = _r[d], v = Sr(h);\n    if (v === o)\n      return h;\n    v < o ? i = d + 1 : c = d - 1;\n  }\n  return \"None\";\n}\nfunction Sr(r) {\n  return r.toLowerCase().replace(/_-\\[\\]/g, \"\");\n}\nfunction Fo(r, o) {\n  return r.Binarizer[o];\n}\nfunction Uo(r, o) {\n  return r.CharacterSet[o];\n}\nconst Wo = [\n  \"Text\",\n  \"Binary\",\n  \"Mixed\",\n  \"GS1\",\n  \"ISO15434\",\n  \"UnknownECI\"\n];\nfunction jo(r) {\n  return Wo[r.value];\n}\nfunction Lo(r, o) {\n  return r.EanAddOnSymbol[o];\n}\nfunction Ho(r, o) {\n  return r.TextMode[o];\n}\nconst Ee = {\n  formats: [],\n  tryHarder: !0,\n  tryRotate: !0,\n  tryInvert: !0,\n  tryDownscale: !0,\n  binarizer: \"LocalAverage\",\n  isPure: !1,\n  downscaleFactor: 3,\n  downscaleThreshold: 500,\n  minLineCount: 2,\n  maxNumberOfSymbols: 255,\n  tryCode39ExtendedMode: !1,\n  validateCode39CheckSum: !1,\n  validateITFCheckSum: !1,\n  returnCodabarStartEnd: !1,\n  returnErrors: !1,\n  eanAddOnSymbol: \"Read\",\n  textMode: \"Plain\",\n  characterSet: \"Unknown\"\n};\nfunction Hr(r, o) {\n  return {\n    ...o,\n    formats: ko(o.formats),\n    binarizer: Fo(r, o.binarizer),\n    eanAddOnSymbol: Lo(\n      r,\n      o.eanAddOnSymbol\n    ),\n    textMode: Ho(r, o.textMode),\n    characterSet: Uo(\n      r,\n      o.characterSet\n    )\n  };\n}\nfunction Br(r) {\n  return {\n    ...r,\n    format: Io(r.format),\n    eccLevel: r.eccLevel,\n    contentType: jo(r.contentType)\n  };\n}\nconst Bo = {\n  locateFile: (r, o) => {\n    const i = r.match(/_(.+?)\\.wasm$/);\n    return i ? `https://fastly.jsdelivr.net/npm/zxing-wasm@1.1.3/dist/${i[1]}/${r}` : o + r;\n  }\n};\nlet Wt = /* @__PURE__ */ new WeakMap();\nfunction Vt(r, o) {\n  var i;\n  const c = Wt.get(r);\n  if (c != null && c.modulePromise && (o === void 0 || Object.is(o, c.moduleOverrides)))\n    return c.modulePromise;\n  const d = (i = o != null ? o : c == null ? void 0 : c.moduleOverrides) != null ? i : Bo, h = r({\n    ...d\n  });\n  return Wt.set(r, {\n    moduleOverrides: d,\n    modulePromise: h\n  }), h;\n}\nfunction Vo(r, o) {\n  Wt.set(r, {\n    moduleOverrides: o\n  });\n}\nasync function No(r, o, i = Ee) {\n  const c = {\n    ...Ee,\n    ...i\n  }, d = await Vt(r), { size: h } = o, v = new Uint8Array(await o.arrayBuffer()), g = d._malloc(h);\n  d.HEAPU8.set(v, g);\n  const b = d.readBarcodesFromImage(\n    g,\n    h,\n    Hr(d, c)\n  );\n  d._free(g);\n  const p = [];\n  for (let C = 0; C < b.size(); ++C)\n    p.push(\n      Br(b.get(C))\n    );\n  return p;\n}\nasync function zo(r, o, i = Ee) {\n  const c = {\n    ...Ee,\n    ...i\n  }, d = await Vt(r), {\n    data: h,\n    width: v,\n    height: g,\n    data: { byteLength: b }\n  } = o, p = d._malloc(b);\n  d.HEAPU8.set(h, p);\n  const C = d.readBarcodesFromPixmap(\n    p,\n    v,\n    g,\n    Hr(d, c)\n  );\n  d._free(p);\n  const S = [];\n  for (let $ = 0; $ < C.size(); ++$)\n    S.push(\n      Br(C.get($))\n    );\n  return S;\n}\n({\n  ...Ee,\n  formats: [...Ee.formats]\n});\nvar ut = (() => {\n  var r = typeof document < \"u\" && document.currentScript ? document.currentScript.src : void 0;\n  return function(o = {}) {\n    var i = o, c, d;\n    i.ready = new Promise((e, t) => {\n      c = e, d = t;\n    });\n    var h = Object.assign({}, i), v = \"./this.program\", g = typeof window == \"object\", b = typeof importScripts == \"function\";\n    typeof process == \"object\" && typeof process.versions == \"object\" && process.versions.node;\n    var p = \"\";\n    function C(e) {\n      return i.locateFile ? i.locateFile(e, p) : p + e;\n    }\n    var S;\n    (g || b) && (b ? p = self.location.href : typeof document < \"u\" && document.currentScript && (p = document.currentScript.src), r && (p = r), p.indexOf(\"blob:\") !== 0 ? p = p.substr(0, p.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : p = \"\", b && (S = (e) => {\n      var t = new XMLHttpRequest();\n      return t.open(\"GET\", e, !1), t.responseType = \"arraybuffer\", t.send(null), new Uint8Array(t.response);\n    })), i.print || console.log.bind(console);\n    var $ = i.printErr || console.error.bind(console);\n    Object.assign(i, h), h = null, i.arguments && i.arguments, i.thisProgram && (v = i.thisProgram), i.quit && i.quit;\n    var F;\n    i.wasmBinary && (F = i.wasmBinary), typeof WebAssembly != \"object\" && Z(\"no native wasm support detected\");\n    var U, W = !1, x, D, X, k, M, A, le, oe;\n    function be() {\n      var e = U.buffer;\n      i.HEAP8 = x = new Int8Array(e), i.HEAP16 = X = new Int16Array(e), i.HEAPU8 = D = new Uint8Array(e), i.HEAPU16 = k = new Uint16Array(e), i.HEAP32 = M = new Int32Array(e), i.HEAPU32 = A = new Uint32Array(e), i.HEAPF32 = le = new Float32Array(e), i.HEAPF64 = oe = new Float64Array(e);\n    }\n    var Ce = [], Oe = [], Me = [];\n    function Le() {\n      if (i.preRun)\n        for (typeof i.preRun == \"function\" && (i.preRun = [i.preRun]); i.preRun.length; )\n          ht(i.preRun.shift());\n      gt(Ce);\n    }\n    function dt() {\n      gt(Oe);\n    }\n    function ft() {\n      if (i.postRun)\n        for (typeof i.postRun == \"function\" && (i.postRun = [i.postRun]); i.postRun.length; )\n          Ae(i.postRun.shift());\n      gt(Me);\n    }\n    function ht(e) {\n      Ce.unshift(e);\n    }\n    function pt(e) {\n      Oe.unshift(e);\n    }\n    function Ae(e) {\n      Me.unshift(e);\n    }\n    var te = 0, ve = null;\n    function mt(e) {\n      var t;\n      te++, (t = i.monitorRunDependencies) === null || t === void 0 || t.call(i, te);\n    }\n    function de(e) {\n      var t;\n      if (te--, (t = i.monitorRunDependencies) === null || t === void 0 || t.call(i, te), te == 0 && ve) {\n        var n = ve;\n        ve = null, n();\n      }\n    }\n    function Z(e) {\n      var t;\n      (t = i.onAbort) === null || t === void 0 || t.call(i, e), e = \"Aborted(\" + e + \")\", $(e), W = !0, e += \". Build with -sASSERTIONS for more info.\";\n      var n = new WebAssembly.RuntimeError(e);\n      throw d(n), n;\n    }\n    var vt = \"data:application/octet-stream;base64,\", He = (e) => e.startsWith(vt), fe;\n    fe = \"zxing_reader.wasm\", He(fe) || (fe = C(fe));\n    function Be(e) {\n      if (e == fe && F)\n        return new Uint8Array(F);\n      if (S)\n        return S(e);\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n    function yt(e) {\n      return !F && (g || b) && typeof fetch == \"function\" ? fetch(e, {\n        credentials: \"same-origin\"\n      }).then((t) => {\n        if (!t.ok)\n          throw \"failed to load wasm binary file at '\" + e + \"'\";\n        return t.arrayBuffer();\n      }).catch(() => Be(e)) : Promise.resolve().then(() => Be(e));\n    }\n    function Ve(e, t, n) {\n      return yt(e).then((a) => WebAssembly.instantiate(a, t)).then((a) => a).then(n, (a) => {\n        $(`failed to asynchronously prepare wasm: ${a}`), Z(a);\n      });\n    }\n    function rn(e, t, n, a) {\n      return !e && typeof WebAssembly.instantiateStreaming == \"function\" && !He(t) && typeof fetch == \"function\" ? fetch(t, {\n        credentials: \"same-origin\"\n      }).then((s) => {\n        var u = WebAssembly.instantiateStreaming(s, n);\n        return u.then(a, function(l) {\n          return $(`wasm streaming compile failed: ${l}`), $(\"falling back to ArrayBuffer instantiation\"), Ve(t, n, a);\n        });\n      }) : Ve(t, n, a);\n    }\n    function nn() {\n      var e = {\n        a: za\n      };\n      function t(a, s) {\n        return G = a.exports, U = G.ia, be(), er = G.ma, pt(G.ja), de(), G;\n      }\n      mt();\n      function n(a) {\n        t(a.instance);\n      }\n      if (i.instantiateWasm)\n        try {\n          return i.instantiateWasm(e, t);\n        } catch (a) {\n          $(`Module.instantiateWasm callback failed with error: ${a}`), d(a);\n        }\n      return rn(F, fe, e, n).catch(d), {};\n    }\n    var gt = (e) => {\n      for (; e.length > 0; )\n        e.shift()(i);\n    };\n    i.noExitRuntime;\n    var Ne = [], ze = 0, an = (e) => {\n      var t = new wt(e);\n      return t.get_caught() || (t.set_caught(!0), ze--), t.set_rethrown(!1), Ne.push(t), pr(t.excPtr), t.get_exception_ptr();\n    }, ie = 0, on = () => {\n      j(0, 0);\n      var e = Ne.pop();\n      hr(e.excPtr), ie = 0;\n    };\n    function wt(e) {\n      this.excPtr = e, this.ptr = e - 24, this.set_type = function(t) {\n        A[this.ptr + 4 >> 2] = t;\n      }, this.get_type = function() {\n        return A[this.ptr + 4 >> 2];\n      }, this.set_destructor = function(t) {\n        A[this.ptr + 8 >> 2] = t;\n      }, this.get_destructor = function() {\n        return A[this.ptr + 8 >> 2];\n      }, this.set_caught = function(t) {\n        t = t ? 1 : 0, x[this.ptr + 12 >> 0] = t;\n      }, this.get_caught = function() {\n        return x[this.ptr + 12 >> 0] != 0;\n      }, this.set_rethrown = function(t) {\n        t = t ? 1 : 0, x[this.ptr + 13 >> 0] = t;\n      }, this.get_rethrown = function() {\n        return x[this.ptr + 13 >> 0] != 0;\n      }, this.init = function(t, n) {\n        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(n);\n      }, this.set_adjusted_ptr = function(t) {\n        A[this.ptr + 16 >> 2] = t;\n      }, this.get_adjusted_ptr = function() {\n        return A[this.ptr + 16 >> 2];\n      }, this.get_exception_ptr = function() {\n        var t = vr(this.get_type());\n        if (t)\n          return A[this.excPtr >> 2];\n        var n = this.get_adjusted_ptr();\n        return n !== 0 ? n : this.excPtr;\n      };\n    }\n    var sn = (e) => {\n      throw ie || (ie = e), ie;\n    }, bt = (e) => {\n      var t = ie;\n      if (!t)\n        return Ue(0), 0;\n      var n = new wt(t);\n      n.set_adjusted_ptr(t);\n      var a = n.get_type();\n      if (!a)\n        return Ue(0), t;\n      for (var s in e) {\n        var u = e[s];\n        if (u === 0 || u === a)\n          break;\n        var l = n.ptr + 16;\n        if (mr(u, a, l))\n          return Ue(u), t;\n      }\n      return Ue(a), t;\n    }, cn = () => bt([]), un = (e) => bt([e]), ln = (e, t) => bt([e, t]), dn = () => {\n      var e = Ne.pop();\n      e || Z(\"no exception to throw\");\n      var t = e.excPtr;\n      throw e.get_rethrown() || (Ne.push(e), e.set_rethrown(!0), e.set_caught(!1), ze++), ie = t, ie;\n    }, fn = (e, t, n) => {\n      var a = new wt(e);\n      throw a.init(t, n), ie = e, ze++, ie;\n    }, hn = () => ze, Ge = {}, Ct = (e) => {\n      for (; e.length; ) {\n        var t = e.pop(), n = e.pop();\n        n(t);\n      }\n    };\n    function $t(e) {\n      return this.fromWireType(M[e >> 2]);\n    }\n    var $e = {}, ye = {}, qe = {}, zt, Ye = (e) => {\n      throw new zt(e);\n    }, ge = (e, t, n) => {\n      e.forEach(function(f) {\n        qe[f] = t;\n      });\n      function a(f) {\n        var m = n(f);\n        m.length !== e.length && Ye(\"Mismatched type converter count\");\n        for (var w = 0; w < e.length; ++w)\n          re(e[w], m[w]);\n      }\n      var s = new Array(t.length), u = [], l = 0;\n      t.forEach((f, m) => {\n        ye.hasOwnProperty(f) ? s[m] = ye[f] : (u.push(f), $e.hasOwnProperty(f) || ($e[f] = []), $e[f].push(() => {\n          s[m] = ye[f], ++l, l === u.length && a(s);\n        }));\n      }), u.length === 0 && a(s);\n    }, pn = (e) => {\n      var t = Ge[e];\n      delete Ge[e];\n      var n = t.rawConstructor, a = t.rawDestructor, s = t.fields, u = s.map((l) => l.getterReturnType).concat(s.map((l) => l.setterArgumentType));\n      ge([e], u, (l) => {\n        var f = {};\n        return s.forEach((m, w) => {\n          var _ = m.fieldName, T = l[w], E = m.getter, O = m.getterContext, L = l[w + s.length], N = m.setter, I = m.setterContext;\n          f[_] = {\n            read: (J) => T.fromWireType(E(O, J)),\n            write: (J, y) => {\n              var P = [];\n              N(I, J, L.toWireType(P, y)), Ct(P);\n            }\n          };\n        }), [{\n          name: t.name,\n          fromWireType: (m) => {\n            var w = {};\n            for (var _ in f)\n              w[_] = f[_].read(m);\n            return a(m), w;\n          },\n          toWireType: (m, w) => {\n            for (var _ in f)\n              if (!(_ in w))\n                throw new TypeError(`Missing field: \"${_}\"`);\n            var T = n();\n            for (_ in f)\n              f[_].write(T, w[_]);\n            return m !== null && m.push(a, T), T;\n          },\n          argPackAdvance: ne,\n          readValueFromPointer: $t,\n          destructorFunction: a\n        }];\n      });\n    }, mn = (e, t, n, a, s) => {\n    }, vn = () => {\n      for (var e = new Array(256), t = 0; t < 256; ++t)\n        e[t] = String.fromCharCode(t);\n      Gt = e;\n    }, Gt, Y = (e) => {\n      for (var t = \"\", n = e; D[n]; )\n        t += Gt[D[n++]];\n      return t;\n    }, _e, R = (e) => {\n      throw new _e(e);\n    };\n    function yn(e, t) {\n      let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n      var a = t.name;\n      if (e || R(`type \"${a}\" must have a positive integer typeid pointer`), ye.hasOwnProperty(e)) {\n        if (n.ignoreDuplicateRegistrations)\n          return;\n        R(`Cannot register type '${a}' twice`);\n      }\n      if (ye[e] = t, delete qe[e], $e.hasOwnProperty(e)) {\n        var s = $e[e];\n        delete $e[e], s.forEach((u) => u());\n      }\n    }\n    function re(e, t) {\n      let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n      if (!(\"argPackAdvance\" in t))\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      return yn(e, t, n);\n    }\n    var ne = 8, gn = (e, t, n, a) => {\n      t = Y(t), re(e, {\n        name: t,\n        fromWireType: function(s) {\n          return !!s;\n        },\n        toWireType: function(s, u) {\n          return u ? n : a;\n        },\n        argPackAdvance: ne,\n        readValueFromPointer: function(s) {\n          return this.fromWireType(D[s]);\n        },\n        destructorFunction: null\n      });\n    }, wn = (e) => ({\n      count: e.count,\n      deleteScheduled: e.deleteScheduled,\n      preservePointerOnDelete: e.preservePointerOnDelete,\n      ptr: e.ptr,\n      ptrType: e.ptrType,\n      smartPtr: e.smartPtr,\n      smartPtrType: e.smartPtrType\n    }), _t = (e) => {\n      function t(n) {\n        return n.$$.ptrType.registeredClass.name;\n      }\n      R(t(e) + \" instance already deleted\");\n    }, St = !1, qt = (e) => {\n    }, bn = (e) => {\n      e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);\n    }, Yt = (e) => {\n      e.count.value -= 1;\n      var t = e.count.value === 0;\n      t && bn(e);\n    }, Jt = (e, t, n) => {\n      if (t === n)\n        return e;\n      if (n.baseClass === void 0)\n        return null;\n      var a = Jt(e, t, n.baseClass);\n      return a === null ? null : n.downcast(a);\n    }, Qt = {}, Cn = () => Object.keys(xe).length, $n = () => {\n      var e = [];\n      for (var t in xe)\n        xe.hasOwnProperty(t) && e.push(xe[t]);\n      return e;\n    }, De = [], Pt = () => {\n      for (; De.length; ) {\n        var e = De.pop();\n        e.$$.deleteScheduled = !1, e.delete();\n      }\n    }, Re, _n = (e) => {\n      Re = e, De.length && Re && Re(Pt);\n    }, Sn = () => {\n      i.getInheritedInstanceCount = Cn, i.getLiveInheritedInstances = $n, i.flushPendingDeletes = Pt, i.setDelayFunction = _n;\n    }, xe = {}, Pn = (e, t) => {\n      for (t === void 0 && R(\"ptr should not be undefined\"); e.baseClass; )\n        t = e.upcast(t), e = e.baseClass;\n      return t;\n    }, Tn = (e, t) => (t = Pn(e, t), xe[t]), Je = (e, t) => {\n      (!t.ptrType || !t.ptr) && Ye(\"makeClassHandle requires ptr and ptrType\");\n      var n = !!t.smartPtrType, a = !!t.smartPtr;\n      return n !== a && Ye(\"Both smartPtrType and smartPtr must be specified\"), t.count = {\n        value: 1\n      }, ke(Object.create(e, {\n        $$: {\n          value: t,\n          writable: !0\n        }\n      }));\n    };\n    function En(e) {\n      var t = this.getPointee(e);\n      if (!t)\n        return this.destructor(e), null;\n      var n = Tn(this.registeredClass, t);\n      if (n !== void 0) {\n        if (n.$$.count.value === 0)\n          return n.$$.ptr = t, n.$$.smartPtr = e, n.clone();\n        var a = n.clone();\n        return this.destructor(e), a;\n      }\n      function s() {\n        return this.isSmartPointer ? Je(this.registeredClass.instancePrototype, {\n          ptrType: this.pointeeType,\n          ptr: t,\n          smartPtrType: this,\n          smartPtr: e\n        }) : Je(this.registeredClass.instancePrototype, {\n          ptrType: this,\n          ptr: e\n        });\n      }\n      var u = this.registeredClass.getActualType(t), l = Qt[u];\n      if (!l)\n        return s.call(this);\n      var f;\n      this.isConst ? f = l.constPointerType : f = l.pointerType;\n      var m = Jt(t, this.registeredClass, f.registeredClass);\n      return m === null ? s.call(this) : this.isSmartPointer ? Je(f.registeredClass.instancePrototype, {\n        ptrType: f,\n        ptr: m,\n        smartPtrType: this,\n        smartPtr: e\n      }) : Je(f.registeredClass.instancePrototype, {\n        ptrType: f,\n        ptr: m\n      });\n    }\n    var ke = (e) => typeof FinalizationRegistry > \"u\" ? (ke = (t) => t, e) : (St = new FinalizationRegistry((t) => {\n      Yt(t.$$);\n    }), ke = (t) => {\n      var n = t.$$, a = !!n.smartPtr;\n      if (a) {\n        var s = {\n          $$: n\n        };\n        St.register(t, s, t);\n      }\n      return t;\n    }, qt = (t) => St.unregister(t), ke(e)), On = () => {\n      Object.assign(Qe.prototype, {\n        isAliasOf(e) {\n          if (!(this instanceof Qe) || !(e instanceof Qe))\n            return !1;\n          var t = this.$$.ptrType.registeredClass, n = this.$$.ptr;\n          e.$$ = e.$$;\n          for (var a = e.$$.ptrType.registeredClass, s = e.$$.ptr; t.baseClass; )\n            n = t.upcast(n), t = t.baseClass;\n          for (; a.baseClass; )\n            s = a.upcast(s), a = a.baseClass;\n          return t === a && n === s;\n        },\n        clone() {\n          if (this.$$.ptr || _t(this), this.$$.preservePointerOnDelete)\n            return this.$$.count.value += 1, this;\n          var e = ke(Object.create(Object.getPrototypeOf(this), {\n            $$: {\n              value: wn(this.$$)\n            }\n          }));\n          return e.$$.count.value += 1, e.$$.deleteScheduled = !1, e;\n        },\n        delete() {\n          this.$$.ptr || _t(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && R(\"Object already scheduled for deletion\"), qt(this), Yt(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);\n        },\n        isDeleted() {\n          return !this.$$.ptr;\n        },\n        deleteLater() {\n          return this.$$.ptr || _t(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && R(\"Object already scheduled for deletion\"), De.push(this), De.length === 1 && Re && Re(Pt), this.$$.deleteScheduled = !0, this;\n        }\n      });\n    };\n    function Qe() {\n    }\n    var Ie = (e, t) => Object.defineProperty(t, \"name\", {\n      value: e\n    }), Xt = (e, t, n) => {\n      if (e[t].overloadTable === void 0) {\n        var a = e[t];\n        e[t] = function() {\n          return e[t].overloadTable.hasOwnProperty(arguments.length) || R(`Function '${n}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[arguments.length].apply(this, arguments);\n        }, e[t].overloadTable = [], e[t].overloadTable[a.argCount] = a;\n      }\n    }, Tt = (e, t, n) => {\n      i.hasOwnProperty(e) ? ((n === void 0 || i[e].overloadTable !== void 0 && i[e].overloadTable[n] !== void 0) && R(`Cannot register public name '${e}' twice`), Xt(i, e, e), i.hasOwnProperty(n) && R(`Cannot register multiple overloads of a function with the same number of arguments (${n})!`), i[e].overloadTable[n] = t) : (i[e] = t, n !== void 0 && (i[e].numArguments = n));\n    }, Mn = 48, An = 57, Dn = (e) => {\n      if (e === void 0)\n        return \"_unknown\";\n      e = e.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var t = e.charCodeAt(0);\n      return t >= Mn && t <= An ? `_${e}` : e;\n    };\n    function Rn(e, t, n, a, s, u, l, f) {\n      this.name = e, this.constructor = t, this.instancePrototype = n, this.rawDestructor = a, this.baseClass = s, this.getActualType = u, this.upcast = l, this.downcast = f, this.pureVirtualFunctions = [];\n    }\n    var Et = (e, t, n) => {\n      for (; t !== n; )\n        t.upcast || R(`Expected null or instance of ${n.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;\n      return e;\n    };\n    function xn(e, t) {\n      if (t === null)\n        return this.isReference && R(`null is not a valid ${this.name}`), 0;\n      t.$$ || R(`Cannot pass \"${Rt(t)}\" as a ${this.name}`), t.$$.ptr || R(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      var n = t.$$.ptrType.registeredClass, a = Et(t.$$.ptr, n, this.registeredClass);\n      return a;\n    }\n    function kn(e, t) {\n      var n;\n      if (t === null)\n        return this.isReference && R(`null is not a valid ${this.name}`), this.isSmartPointer ? (n = this.rawConstructor(), e !== null && e.push(this.rawDestructor, n), n) : 0;\n      (!t || !t.$$) && R(`Cannot pass \"${Rt(t)}\" as a ${this.name}`), t.$$.ptr || R(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && R(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);\n      var a = t.$$.ptrType.registeredClass;\n      if (n = Et(t.$$.ptr, a, this.registeredClass), this.isSmartPointer)\n        switch (t.$$.smartPtr === void 0 && R(\"Passing raw pointer to smart pointer is illegal\"), this.sharingPolicy) {\n          case 0:\n            t.$$.smartPtrType === this ? n = t.$$.smartPtr : R(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);\n            break;\n          case 1:\n            n = t.$$.smartPtr;\n            break;\n          case 2:\n            if (t.$$.smartPtrType === this)\n              n = t.$$.smartPtr;\n            else {\n              var s = t.clone();\n              n = this.rawShare(n, se.toHandle(() => s.delete())), e !== null && e.push(this.rawDestructor, n);\n            }\n            break;\n          default:\n            R(\"Unsupporting sharing policy\");\n        }\n      return n;\n    }\n    function In(e, t) {\n      if (t === null)\n        return this.isReference && R(`null is not a valid ${this.name}`), 0;\n      t.$$ || R(`Cannot pass \"${Rt(t)}\" as a ${this.name}`), t.$$.ptr || R(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && R(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);\n      var n = t.$$.ptrType.registeredClass, a = Et(t.$$.ptr, n, this.registeredClass);\n      return a;\n    }\n    function Zt(e) {\n      return this.fromWireType(A[e >> 2]);\n    }\n    var Fn = () => {\n      Object.assign(Xe.prototype, {\n        getPointee(e) {\n          return this.rawGetPointee && (e = this.rawGetPointee(e)), e;\n        },\n        destructor(e) {\n          var t;\n          (t = this.rawDestructor) === null || t === void 0 || t.call(this, e);\n        },\n        argPackAdvance: ne,\n        readValueFromPointer: Zt,\n        deleteObject(e) {\n          e !== null && e.delete();\n        },\n        fromWireType: En\n      });\n    };\n    function Xe(e, t, n, a, s, u, l, f, m, w, _) {\n      this.name = e, this.registeredClass = t, this.isReference = n, this.isConst = a, this.isSmartPointer = s, this.pointeeType = u, this.sharingPolicy = l, this.rawGetPointee = f, this.rawConstructor = m, this.rawShare = w, this.rawDestructor = _, !s && t.baseClass === void 0 ? a ? (this.toWireType = xn, this.destructorFunction = null) : (this.toWireType = In, this.destructorFunction = null) : this.toWireType = kn;\n    }\n    var Kt = (e, t, n) => {\n      i.hasOwnProperty(e) || Ye(\"Replacing nonexistant public symbol\"), i[e].overloadTable !== void 0 && n !== void 0 ? i[e].overloadTable[n] = t : (i[e] = t, i[e].argCount = n);\n    }, Un = (e, t, n) => {\n      var a = i[\"dynCall_\" + e];\n      return n && n.length ? a.apply(null, [t].concat(n)) : a.call(null, t);\n    }, Ze = [], er, H = (e) => {\n      var t = Ze[e];\n      return t || (e >= Ze.length && (Ze.length = e + 1), Ze[e] = t = er.get(e)), t;\n    }, Wn = (e, t, n) => {\n      if (e.includes(\"j\"))\n        return Un(e, t, n);\n      var a = H(t).apply(null, n);\n      return a;\n    }, jn = (e, t) => {\n      var n = [];\n      return function() {\n        return n.length = 0, Object.assign(n, arguments), Wn(e, t, n);\n      };\n    }, ee = (e, t) => {\n      e = Y(e);\n      function n() {\n        return e.includes(\"j\") ? jn(e, t) : H(t);\n      }\n      var a = n();\n      return typeof a != \"function\" && R(`unknown function pointer with signature ${e}: ${t}`), a;\n    }, Ln = (e, t) => {\n      var n = Ie(t, function(a) {\n        this.name = t, this.message = a;\n        var s = new Error(a).stack;\n        s !== void 0 && (this.stack = this.toString() + `\n` + s.replace(/^Error(:[^\\n]*)?\\n/, \"\"));\n      });\n      return n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.prototype.toString = function() {\n        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;\n      }, n;\n    }, tr, rr = (e) => {\n      var t = fr(e), n = Y(t);\n      return ce(t), n;\n    }, Ke = (e, t) => {\n      var n = [], a = {};\n      function s(u) {\n        if (!a[u] && !ye[u]) {\n          if (qe[u]) {\n            qe[u].forEach(s);\n            return;\n          }\n          n.push(u), a[u] = !0;\n        }\n      }\n      throw t.forEach(s), new tr(`${e}: ` + n.map(rr).join([\", \"]));\n    }, Hn = (e, t, n, a, s, u, l, f, m, w, _, T, E) => {\n      _ = Y(_), u = ee(s, u), f && (f = ee(l, f)), w && (w = ee(m, w)), E = ee(T, E);\n      var O = Dn(_);\n      Tt(O, function() {\n        Ke(`Cannot construct ${_} due to unbound types`, [a]);\n      }), ge([e, t, n], a ? [a] : [], function(L) {\n        L = L[0];\n        var N, I;\n        a ? (N = L.registeredClass, I = N.instancePrototype) : I = Qe.prototype;\n        var J = Ie(_, function() {\n          if (Object.getPrototypeOf(this) !== y)\n            throw new _e(\"Use 'new' to construct \" + _);\n          if (P.constructor_body === void 0)\n            throw new _e(_ + \" has no accessible constructor\");\n          var br = P.constructor_body[arguments.length];\n          if (br === void 0)\n            throw new _e(`Tried to invoke ctor of ${_} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(P.constructor_body).toString()}) parameters instead!`);\n          return br.apply(this, arguments);\n        }), y = Object.create(I, {\n          constructor: {\n            value: J\n          }\n        });\n        J.prototype = y;\n        var P = new Rn(_, J, y, E, N, u, f, w);\n        if (P.baseClass) {\n          var z, q;\n          (q = (z = P.baseClass).__derivedClasses) !== null && q !== void 0 || (z.__derivedClasses = []), P.baseClass.__derivedClasses.push(P);\n        }\n        var Se = new Xe(_, P, !0, !1, !1), rt = new Xe(_ + \"*\", P, !1, !1, !1), wr = new Xe(_ + \" const*\", P, !1, !0, !1);\n        return Qt[e] = {\n          pointerType: rt,\n          constPointerType: wr\n        }, Kt(O, J), [Se, rt, wr];\n      });\n    }, Ot = (e, t) => {\n      for (var n = [], a = 0; a < e; a++)\n        n.push(A[t + a * 4 >> 2]);\n      return n;\n    };\n    function Bn(e) {\n      for (var t = 1; t < e.length; ++t)\n        if (e[t] !== null && e[t].destructorFunction === void 0)\n          return !0;\n      return !1;\n    }\n    function Mt(e, t, n, a, s, u) {\n      var l = t.length;\n      l < 2 && R(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      var f = t[1] !== null && n !== null, m = Bn(t), w = t[0].name !== \"void\", _ = l - 2, T = new Array(_), E = [], O = [], L = function() {\n        arguments.length !== _ && R(`function ${e} called with ${arguments.length} arguments, expected ${_}`), O.length = 0;\n        var N;\n        E.length = f ? 2 : 1, E[0] = s, f && (N = t[1].toWireType(O, this), E[1] = N);\n        for (var I = 0; I < _; ++I)\n          T[I] = t[I + 2].toWireType(O, arguments[I]), E.push(T[I]);\n        var J = a.apply(null, E);\n        function y(P) {\n          if (m)\n            Ct(O);\n          else\n            for (var z = f ? 1 : 2; z < t.length; z++) {\n              var q = z === 1 ? N : T[z - 2];\n              t[z].destructorFunction !== null && t[z].destructorFunction(q);\n            }\n          if (w)\n            return t[0].fromWireType(P);\n        }\n        return y(J);\n      };\n      return Ie(e, L);\n    }\n    var Vn = (e, t, n, a, s, u) => {\n      var l = Ot(t, n);\n      s = ee(a, s), ge([], [e], function(f) {\n        f = f[0];\n        var m = `constructor ${f.name}`;\n        if (f.registeredClass.constructor_body === void 0 && (f.registeredClass.constructor_body = []), f.registeredClass.constructor_body[t - 1] !== void 0)\n          throw new _e(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${f.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n        return f.registeredClass.constructor_body[t - 1] = () => {\n          Ke(`Cannot construct ${f.name} due to unbound types`, l);\n        }, ge([], l, (w) => (w.splice(1, 0, null), f.registeredClass.constructor_body[t - 1] = Mt(m, w, null, s, u), [])), [];\n      });\n    }, nr = (e) => {\n      e = e.trim();\n      const t = e.indexOf(\"(\");\n      return t !== -1 ? e.substr(0, t) : e;\n    }, Nn = (e, t, n, a, s, u, l, f, m) => {\n      var w = Ot(n, a);\n      t = Y(t), t = nr(t), u = ee(s, u), ge([], [e], function(_) {\n        _ = _[0];\n        var T = `${_.name}.${t}`;\n        t.startsWith(\"@@\") && (t = Symbol[t.substring(2)]), f && _.registeredClass.pureVirtualFunctions.push(t);\n        function E() {\n          Ke(`Cannot call ${T} due to unbound types`, w);\n        }\n        var O = _.registeredClass.instancePrototype, L = O[t];\n        return L === void 0 || L.overloadTable === void 0 && L.className !== _.name && L.argCount === n - 2 ? (E.argCount = n - 2, E.className = _.name, O[t] = E) : (Xt(O, t, T), O[t].overloadTable[n - 2] = E), ge([], w, function(N) {\n          var I = Mt(T, N, _, u, l);\n          return O[t].overloadTable === void 0 ? (I.argCount = n - 2, O[t] = I) : O[t].overloadTable[n - 2] = I, [];\n        }), [];\n      });\n    };\n    function zn() {\n      Object.assign(ar.prototype, {\n        get(e) {\n          return this.allocated[e];\n        },\n        has(e) {\n          return this.allocated[e] !== void 0;\n        },\n        allocate(e) {\n          var t = this.freelist.pop() || this.allocated.length;\n          return this.allocated[t] = e, t;\n        },\n        free(e) {\n          this.allocated[e] = void 0, this.freelist.push(e);\n        }\n      });\n    }\n    function ar() {\n      this.allocated = [void 0], this.freelist = [];\n    }\n    var K = new ar(), At = (e) => {\n      e >= K.reserved && --K.get(e).refcount === 0 && K.free(e);\n    }, Gn = () => {\n      for (var e = 0, t = K.reserved; t < K.allocated.length; ++t)\n        K.allocated[t] !== void 0 && ++e;\n      return e;\n    }, qn = () => {\n      K.allocated.push({\n        value: void 0\n      }, {\n        value: null\n      }, {\n        value: !0\n      }, {\n        value: !1\n      }), K.reserved = K.allocated.length, i.count_emval_handles = Gn;\n    }, se = {\n      toValue: (e) => (e || R(\"Cannot use deleted val. handle = \" + e), K.get(e).value),\n      toHandle: (e) => {\n        switch (e) {\n          case void 0:\n            return 1;\n          case null:\n            return 2;\n          case !0:\n            return 3;\n          case !1:\n            return 4;\n          default:\n            return K.allocate({\n              refcount: 1,\n              value: e\n            });\n        }\n      }\n    }, Yn = (e, t) => {\n      t = Y(t), re(e, {\n        name: t,\n        fromWireType: (n) => {\n          var a = se.toValue(n);\n          return At(n), a;\n        },\n        toWireType: (n, a) => se.toHandle(a),\n        argPackAdvance: ne,\n        readValueFromPointer: $t,\n        destructorFunction: null\n      });\n    }, Jn = (e, t, n) => {\n      switch (t) {\n        case 1:\n          return n ? function(a) {\n            return this.fromWireType(x[a >> 0]);\n          } : function(a) {\n            return this.fromWireType(D[a >> 0]);\n          };\n        case 2:\n          return n ? function(a) {\n            return this.fromWireType(X[a >> 1]);\n          } : function(a) {\n            return this.fromWireType(k[a >> 1]);\n          };\n        case 4:\n          return n ? function(a) {\n            return this.fromWireType(M[a >> 2]);\n          } : function(a) {\n            return this.fromWireType(A[a >> 2]);\n          };\n        default:\n          throw new TypeError(`invalid integer width (${t}): ${e}`);\n      }\n    }, Qn = (e, t, n, a) => {\n      t = Y(t);\n      function s() {\n      }\n      s.values = {}, re(e, {\n        name: t,\n        constructor: s,\n        fromWireType: function(u) {\n          return this.constructor.values[u];\n        },\n        toWireType: (u, l) => l.value,\n        argPackAdvance: ne,\n        readValueFromPointer: Jn(t, n, a),\n        destructorFunction: null\n      }), Tt(t, s);\n    }, Dt = (e, t) => {\n      var n = ye[e];\n      return n === void 0 && R(t + \" has unknown type \" + rr(e)), n;\n    }, Xn = (e, t, n) => {\n      var a = Dt(e, \"enum\");\n      t = Y(t);\n      var s = a.constructor, u = Object.create(a.constructor.prototype, {\n        value: {\n          value: n\n        },\n        constructor: {\n          value: Ie(`${a.name}_${t}`, function() {\n          })\n        }\n      });\n      s.values[n] = u, s[t] = u;\n    }, Rt = (e) => {\n      if (e === null)\n        return \"null\";\n      var t = typeof e;\n      return t === \"object\" || t === \"array\" || t === \"function\" ? e.toString() : \"\" + e;\n    }, Zn = (e, t) => {\n      switch (t) {\n        case 4:\n          return function(n) {\n            return this.fromWireType(le[n >> 2]);\n          };\n        case 8:\n          return function(n) {\n            return this.fromWireType(oe[n >> 3]);\n          };\n        default:\n          throw new TypeError(`invalid float width (${t}): ${e}`);\n      }\n    }, Kn = (e, t, n) => {\n      t = Y(t), re(e, {\n        name: t,\n        fromWireType: (a) => a,\n        toWireType: (a, s) => s,\n        argPackAdvance: ne,\n        readValueFromPointer: Zn(t, n),\n        destructorFunction: null\n      });\n    }, ea = (e, t, n, a, s, u, l) => {\n      var f = Ot(t, n);\n      e = Y(e), e = nr(e), s = ee(a, s), Tt(e, function() {\n        Ke(`Cannot call ${e} due to unbound types`, f);\n      }, t - 1), ge([], f, function(m) {\n        var w = [m[0], null].concat(m.slice(1));\n        return Kt(e, Mt(e, w, null, s, u), t - 1), [];\n      });\n    }, ta = (e, t, n) => {\n      switch (t) {\n        case 1:\n          return n ? (a) => x[a >> 0] : (a) => D[a >> 0];\n        case 2:\n          return n ? (a) => X[a >> 1] : (a) => k[a >> 1];\n        case 4:\n          return n ? (a) => M[a >> 2] : (a) => A[a >> 2];\n        default:\n          throw new TypeError(`invalid integer width (${t}): ${e}`);\n      }\n    }, ra = (e, t, n, a, s) => {\n      t = Y(t);\n      var u = (_) => _;\n      if (a === 0) {\n        var l = 32 - 8 * n;\n        u = (_) => _ << l >>> l;\n      }\n      var f = t.includes(\"unsigned\"), m = (_, T) => {\n      }, w;\n      f ? w = function(_, T) {\n        return m(T, this.name), T >>> 0;\n      } : w = function(_, T) {\n        return m(T, this.name), T;\n      }, re(e, {\n        name: t,\n        fromWireType: u,\n        toWireType: w,\n        argPackAdvance: ne,\n        readValueFromPointer: ta(t, n, a !== 0),\n        destructorFunction: null\n      });\n    }, na = (e, t, n) => {\n      var a = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], s = a[t];\n      function u(l) {\n        var f = A[l >> 2], m = A[l + 4 >> 2];\n        return new s(x.buffer, m, f);\n      }\n      n = Y(n), re(e, {\n        name: n,\n        fromWireType: u,\n        argPackAdvance: ne,\n        readValueFromPointer: u\n      }, {\n        ignoreDuplicateRegistrations: !0\n      });\n    }, or = (e, t, n, a) => {\n      if (!(a > 0))\n        return 0;\n      for (var s = n, u = n + a - 1, l = 0; l < e.length; ++l) {\n        var f = e.charCodeAt(l);\n        if (f >= 55296 && f <= 57343) {\n          var m = e.charCodeAt(++l);\n          f = 65536 + ((f & 1023) << 10) | m & 1023;\n        }\n        if (f <= 127) {\n          if (n >= u)\n            break;\n          t[n++] = f;\n        } else if (f <= 2047) {\n          if (n + 1 >= u)\n            break;\n          t[n++] = 192 | f >> 6, t[n++] = 128 | f & 63;\n        } else if (f <= 65535) {\n          if (n + 2 >= u)\n            break;\n          t[n++] = 224 | f >> 12, t[n++] = 128 | f >> 6 & 63, t[n++] = 128 | f & 63;\n        } else {\n          if (n + 3 >= u)\n            break;\n          t[n++] = 240 | f >> 18, t[n++] = 128 | f >> 12 & 63, t[n++] = 128 | f >> 6 & 63, t[n++] = 128 | f & 63;\n        }\n      }\n      return t[n] = 0, n - s;\n    }, aa = (e, t, n) => or(e, D, t, n), ir = (e) => {\n      for (var t = 0, n = 0; n < e.length; ++n) {\n        var a = e.charCodeAt(n);\n        a <= 127 ? t++ : a <= 2047 ? t += 2 : a >= 55296 && a <= 57343 ? (t += 4, ++n) : t += 3;\n      }\n      return t;\n    }, sr = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf8\") : void 0, oa = (e, t, n) => {\n      for (var a = t + n, s = t; e[s] && !(s >= a); )\n        ++s;\n      if (s - t > 16 && e.buffer && sr)\n        return sr.decode(e.subarray(t, s));\n      for (var u = \"\"; t < s; ) {\n        var l = e[t++];\n        if (!(l & 128)) {\n          u += String.fromCharCode(l);\n          continue;\n        }\n        var f = e[t++] & 63;\n        if ((l & 224) == 192) {\n          u += String.fromCharCode((l & 31) << 6 | f);\n          continue;\n        }\n        var m = e[t++] & 63;\n        if ((l & 240) == 224 ? l = (l & 15) << 12 | f << 6 | m : l = (l & 7) << 18 | f << 12 | m << 6 | e[t++] & 63, l < 65536)\n          u += String.fromCharCode(l);\n        else {\n          var w = l - 65536;\n          u += String.fromCharCode(55296 | w >> 10, 56320 | w & 1023);\n        }\n      }\n      return u;\n    }, xt = (e, t) => e ? oa(D, e, t) : \"\", ia = (e, t) => {\n      t = Y(t);\n      var n = t === \"std::string\";\n      re(e, {\n        name: t,\n        fromWireType(a) {\n          var s = A[a >> 2], u = a + 4, l;\n          if (n)\n            for (var f = u, m = 0; m <= s; ++m) {\n              var w = u + m;\n              if (m == s || D[w] == 0) {\n                var _ = w - f, T = xt(f, _);\n                l === void 0 ? l = T : (l += \"\\0\", l += T), f = w + 1;\n              }\n            }\n          else {\n            for (var E = new Array(s), m = 0; m < s; ++m)\n              E[m] = String.fromCharCode(D[u + m]);\n            l = E.join(\"\");\n          }\n          return ce(a), l;\n        },\n        toWireType(a, s) {\n          s instanceof ArrayBuffer && (s = new Uint8Array(s));\n          var u, l = typeof s == \"string\";\n          l || s instanceof Uint8Array || s instanceof Uint8ClampedArray || s instanceof Int8Array || R(\"Cannot pass non-string to std::string\"), n && l ? u = ir(s) : u = s.length;\n          var f = Ft(4 + u + 1), m = f + 4;\n          if (A[f >> 2] = u, n && l)\n            aa(s, m, u + 1);\n          else if (l)\n            for (var w = 0; w < u; ++w) {\n              var _ = s.charCodeAt(w);\n              _ > 255 && (ce(m), R(\"String has UTF-16 code units that do not fit in 8 bits\")), D[m + w] = _;\n            }\n          else\n            for (var w = 0; w < u; ++w)\n              D[m + w] = s[w];\n          return a !== null && a.push(ce, f), f;\n        },\n        argPackAdvance: ne,\n        readValueFromPointer: Zt,\n        destructorFunction(a) {\n          ce(a);\n        }\n      });\n    }, cr = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-16le\") : void 0, sa = (e, t) => {\n      for (var n = e, a = n >> 1, s = a + t / 2; !(a >= s) && k[a]; )\n        ++a;\n      if (n = a << 1, n - e > 32 && cr)\n        return cr.decode(D.subarray(e, n));\n      for (var u = \"\", l = 0; !(l >= t / 2); ++l) {\n        var f = X[e + l * 2 >> 1];\n        if (f == 0)\n          break;\n        u += String.fromCharCode(f);\n      }\n      return u;\n    }, ca = (e, t, n) => {\n      var a;\n      if ((a = n) !== null && a !== void 0 || (n = 2147483647), n < 2)\n        return 0;\n      n -= 2;\n      for (var s = t, u = n < e.length * 2 ? n / 2 : e.length, l = 0; l < u; ++l) {\n        var f = e.charCodeAt(l);\n        X[t >> 1] = f, t += 2;\n      }\n      return X[t >> 1] = 0, t - s;\n    }, ua = (e) => e.length * 2, la = (e, t) => {\n      for (var n = 0, a = \"\"; !(n >= t / 4); ) {\n        var s = M[e + n * 4 >> 2];\n        if (s == 0)\n          break;\n        if (++n, s >= 65536) {\n          var u = s - 65536;\n          a += String.fromCharCode(55296 | u >> 10, 56320 | u & 1023);\n        } else\n          a += String.fromCharCode(s);\n      }\n      return a;\n    }, da = (e, t, n) => {\n      var a;\n      if ((a = n) !== null && a !== void 0 || (n = 2147483647), n < 4)\n        return 0;\n      for (var s = t, u = s + n - 4, l = 0; l < e.length; ++l) {\n        var f = e.charCodeAt(l);\n        if (f >= 55296 && f <= 57343) {\n          var m = e.charCodeAt(++l);\n          f = 65536 + ((f & 1023) << 10) | m & 1023;\n        }\n        if (M[t >> 2] = f, t += 4, t + 4 > u)\n          break;\n      }\n      return M[t >> 2] = 0, t - s;\n    }, fa = (e) => {\n      for (var t = 0, n = 0; n < e.length; ++n) {\n        var a = e.charCodeAt(n);\n        a >= 55296 && a <= 57343 && ++n, t += 4;\n      }\n      return t;\n    }, ha = (e, t, n) => {\n      n = Y(n);\n      var a, s, u, l, f;\n      t === 2 ? (a = sa, s = ca, l = ua, u = () => k, f = 1) : t === 4 && (a = la, s = da, l = fa, u = () => A, f = 2), re(e, {\n        name: n,\n        fromWireType: (m) => {\n          for (var w = A[m >> 2], _ = u(), T, E = m + 4, O = 0; O <= w; ++O) {\n            var L = m + 4 + O * t;\n            if (O == w || _[L >> f] == 0) {\n              var N = L - E, I = a(E, N);\n              T === void 0 ? T = I : (T += \"\\0\", T += I), E = L + t;\n            }\n          }\n          return ce(m), T;\n        },\n        toWireType: (m, w) => {\n          typeof w != \"string\" && R(`Cannot pass non-string to C++ string type ${n}`);\n          var _ = l(w), T = Ft(4 + _ + t);\n          return A[T >> 2] = _ >> f, s(w, T + 4, _ + t), m !== null && m.push(ce, T), T;\n        },\n        argPackAdvance: ne,\n        readValueFromPointer: $t,\n        destructorFunction(m) {\n          ce(m);\n        }\n      });\n    }, pa = (e, t, n, a, s, u) => {\n      Ge[e] = {\n        name: Y(t),\n        rawConstructor: ee(n, a),\n        rawDestructor: ee(s, u),\n        fields: []\n      };\n    }, ma = (e, t, n, a, s, u, l, f, m, w) => {\n      Ge[e].fields.push({\n        fieldName: Y(t),\n        getterReturnType: n,\n        getter: ee(a, s),\n        getterContext: u,\n        setterArgumentType: l,\n        setter: ee(f, m),\n        setterContext: w\n      });\n    }, va = (e, t) => {\n      t = Y(t), re(e, {\n        isVoid: !0,\n        name: t,\n        argPackAdvance: 0,\n        fromWireType: () => {\n        },\n        toWireType: (n, a) => {\n        }\n      });\n    }, kt = [], ya = (e, t, n, a) => (e = kt[e], t = se.toValue(t), e(null, t, n, a)), ga = {}, wa = (e) => {\n      var t = ga[e];\n      return t === void 0 ? Y(e) : t;\n    }, ur = () => {\n      if (typeof globalThis == \"object\")\n        return globalThis;\n      function e(t) {\n        t.$$$embind_global$$$ = t;\n        var n = typeof $$$embind_global$$$ == \"object\" && t.$$$embind_global$$$ == t;\n        return n || delete t.$$$embind_global$$$, n;\n      }\n      if (typeof $$$embind_global$$$ == \"object\" || (typeof global == \"object\" && e(global) ? $$$embind_global$$$ = global : typeof self == \"object\" && e(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == \"object\"))\n        return $$$embind_global$$$;\n      throw Error(\"unable to get global object.\");\n    }, ba = (e) => e === 0 ? se.toHandle(ur()) : (e = wa(e), se.toHandle(ur()[e])), Ca = (e) => {\n      var t = kt.length;\n      return kt.push(e), t;\n    }, $a = (e, t) => {\n      for (var n = new Array(e), a = 0; a < e; ++a)\n        n[a] = Dt(A[t + a * 4 >> 2], \"parameter \" + a);\n      return n;\n    }, _a = Reflect.construct, Sa = (e, t, n) => {\n      var a = [], s = e.toWireType(a, n);\n      return a.length && (A[t >> 2] = se.toHandle(a)), s;\n    }, Pa = (e, t, n) => {\n      var a = $a(e, t), s = a.shift();\n      e--;\n      var u = new Array(e), l = (m, w, _, T) => {\n        for (var E = 0, O = 0; O < e; ++O)\n          u[O] = a[O].readValueFromPointer(T + E), E += a[O].argPackAdvance;\n        for (var L = n === 1 ? _a(w, u) : w.apply(m, u), O = 0; O < e; ++O) {\n          var N, I;\n          (N = (I = a[O]).deleteObject) === null || N === void 0 || N.call(I, u[O]);\n        }\n        return Sa(s, _, L);\n      }, f = `methodCaller<(${a.map((m) => m.name).join(\", \")}) => ${s.name}>`;\n      return Ca(Ie(f, l));\n    }, Ta = (e) => {\n      e > 4 && (K.get(e).refcount += 1);\n    }, Ea = (e) => {\n      var t = se.toValue(e);\n      Ct(t), At(e);\n    }, Oa = (e, t) => {\n      e = Dt(e, \"_emval_take_value\");\n      var n = e.readValueFromPointer(t);\n      return se.toHandle(n);\n    }, Ma = () => {\n      Z(\"\");\n    }, Aa = (e, t, n) => D.copyWithin(e, t, t + n), Da = () => 2147483648, Ra = (e) => {\n      var t = U.buffer, n = (e - t.byteLength + 65535) / 65536;\n      try {\n        return U.grow(n), be(), 1;\n      } catch (a) {\n      }\n    }, xa = (e) => {\n      var t = D.length;\n      e >>>= 0;\n      var n = Da();\n      if (e > n)\n        return !1;\n      for (var a = (m, w) => m + (w - m % w) % w, s = 1; s <= 4; s *= 2) {\n        var u = t * (1 + 0.2 / s);\n        u = Math.min(u, e + 100663296);\n        var l = Math.min(n, a(Math.max(e, u), 65536)), f = Ra(l);\n        if (f)\n          return !0;\n      }\n      return !1;\n    }, It = {}, ka = () => v || \"./this.program\", Fe = () => {\n      if (!Fe.strings) {\n        var e = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\", t = {\n          USER: \"web_user\",\n          LOGNAME: \"web_user\",\n          PATH: \"/\",\n          PWD: \"/\",\n          HOME: \"/home/web_user\",\n          LANG: e,\n          _: ka()\n        };\n        for (var n in It)\n          It[n] === void 0 ? delete t[n] : t[n] = It[n];\n        var a = [];\n        for (var n in t)\n          a.push(`${n}=${t[n]}`);\n        Fe.strings = a;\n      }\n      return Fe.strings;\n    }, Ia = (e, t) => {\n      for (var n = 0; n < e.length; ++n)\n        x[t++ >> 0] = e.charCodeAt(n);\n      x[t >> 0] = 0;\n    }, Fa = (e, t) => {\n      var n = 0;\n      return Fe().forEach((a, s) => {\n        var u = t + n;\n        A[e + s * 4 >> 2] = u, Ia(a, u), n += a.length + 1;\n      }), 0;\n    }, Ua = (e, t) => {\n      var n = Fe();\n      A[e >> 2] = n.length;\n      var a = 0;\n      return n.forEach((s) => a += s.length + 1), A[t >> 2] = a, 0;\n    }, Wa = (e) => e, et = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), ja = (e, t) => {\n      for (var n = 0, a = 0; a <= t; n += e[a++])\n        ;\n      return n;\n    }, lr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], dr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], La = (e, t) => {\n      for (var n = new Date(e.getTime()); t > 0; ) {\n        var a = et(n.getFullYear()), s = n.getMonth(), u = (a ? lr : dr)[s];\n        if (t > u - n.getDate())\n          t -= u - n.getDate() + 1, n.setDate(1), s < 11 ? n.setMonth(s + 1) : (n.setMonth(0), n.setFullYear(n.getFullYear() + 1));\n        else\n          return n.setDate(n.getDate() + t), n;\n      }\n      return n;\n    };\n    function Ha(e, t, n) {\n      var a = n > 0 ? n : ir(e) + 1, s = new Array(a), u = or(e, s, 0, s.length);\n      return t && (s.length = u), s;\n    }\n    var Ba = (e, t) => {\n      x.set(e, t);\n    }, Va = (e, t, n, a) => {\n      var s = A[a + 40 >> 2], u = {\n        tm_sec: M[a >> 2],\n        tm_min: M[a + 4 >> 2],\n        tm_hour: M[a + 8 >> 2],\n        tm_mday: M[a + 12 >> 2],\n        tm_mon: M[a + 16 >> 2],\n        tm_year: M[a + 20 >> 2],\n        tm_wday: M[a + 24 >> 2],\n        tm_yday: M[a + 28 >> 2],\n        tm_isdst: M[a + 32 >> 2],\n        tm_gmtoff: M[a + 36 >> 2],\n        tm_zone: s ? xt(s) : \"\"\n      }, l = xt(n), f = {\n        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n        \"%D\": \"%m/%d/%y\",\n        \"%F\": \"%Y-%m-%d\",\n        \"%h\": \"%b\",\n        \"%r\": \"%I:%M:%S %p\",\n        \"%R\": \"%H:%M\",\n        \"%T\": \"%H:%M:%S\",\n        \"%x\": \"%m/%d/%y\",\n        \"%X\": \"%H:%M:%S\",\n        \"%Ec\": \"%c\",\n        \"%EC\": \"%C\",\n        \"%Ex\": \"%m/%d/%y\",\n        \"%EX\": \"%H:%M:%S\",\n        \"%Ey\": \"%y\",\n        \"%EY\": \"%Y\",\n        \"%Od\": \"%d\",\n        \"%Oe\": \"%e\",\n        \"%OH\": \"%H\",\n        \"%OI\": \"%I\",\n        \"%Om\": \"%m\",\n        \"%OM\": \"%M\",\n        \"%OS\": \"%S\",\n        \"%Ou\": \"%u\",\n        \"%OU\": \"%U\",\n        \"%OV\": \"%V\",\n        \"%Ow\": \"%w\",\n        \"%OW\": \"%W\",\n        \"%Oy\": \"%y\"\n      };\n      for (var m in f)\n        l = l.replace(new RegExp(m, \"g\"), f[m]);\n      var w = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], _ = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n      function T(y, P, z) {\n        for (var q = typeof y == \"number\" ? y.toString() : y || \"\"; q.length < P; )\n          q = z[0] + q;\n        return q;\n      }\n      function E(y, P) {\n        return T(y, P, \"0\");\n      }\n      function O(y, P) {\n        function z(Se) {\n          return Se < 0 ? -1 : Se > 0 ? 1 : 0;\n        }\n        var q;\n        return (q = z(y.getFullYear() - P.getFullYear())) === 0 && (q = z(y.getMonth() - P.getMonth())) === 0 && (q = z(y.getDate() - P.getDate())), q;\n      }\n      function L(y) {\n        switch (y.getDay()) {\n          case 0:\n            return new Date(y.getFullYear() - 1, 11, 29);\n          case 1:\n            return y;\n          case 2:\n            return new Date(y.getFullYear(), 0, 3);\n          case 3:\n            return new Date(y.getFullYear(), 0, 2);\n          case 4:\n            return new Date(y.getFullYear(), 0, 1);\n          case 5:\n            return new Date(y.getFullYear() - 1, 11, 31);\n          case 6:\n            return new Date(y.getFullYear() - 1, 11, 30);\n        }\n      }\n      function N(y) {\n        var P = La(new Date(y.tm_year + 1900, 0, 1), y.tm_yday), z = new Date(P.getFullYear(), 0, 4), q = new Date(P.getFullYear() + 1, 0, 4), Se = L(z), rt = L(q);\n        return O(Se, P) <= 0 ? O(rt, P) <= 0 ? P.getFullYear() + 1 : P.getFullYear() : P.getFullYear() - 1;\n      }\n      var I = {\n        \"%a\": (y) => w[y.tm_wday].substring(0, 3),\n        \"%A\": (y) => w[y.tm_wday],\n        \"%b\": (y) => _[y.tm_mon].substring(0, 3),\n        \"%B\": (y) => _[y.tm_mon],\n        \"%C\": (y) => {\n          var P = y.tm_year + 1900;\n          return E(P / 100 | 0, 2);\n        },\n        \"%d\": (y) => E(y.tm_mday, 2),\n        \"%e\": (y) => T(y.tm_mday, 2, \" \"),\n        \"%g\": (y) => N(y).toString().substring(2),\n        \"%G\": (y) => N(y),\n        \"%H\": (y) => E(y.tm_hour, 2),\n        \"%I\": (y) => {\n          var P = y.tm_hour;\n          return P == 0 ? P = 12 : P > 12 && (P -= 12), E(P, 2);\n        },\n        \"%j\": (y) => E(y.tm_mday + ja(et(y.tm_year + 1900) ? lr : dr, y.tm_mon - 1), 3),\n        \"%m\": (y) => E(y.tm_mon + 1, 2),\n        \"%M\": (y) => E(y.tm_min, 2),\n        \"%n\": () => `\n`,\n        \"%p\": (y) => y.tm_hour >= 0 && y.tm_hour < 12 ? \"AM\" : \"PM\",\n        \"%S\": (y) => E(y.tm_sec, 2),\n        \"%t\": () => \"\t\",\n        \"%u\": (y) => y.tm_wday || 7,\n        \"%U\": (y) => {\n          var P = y.tm_yday + 7 - y.tm_wday;\n          return E(Math.floor(P / 7), 2);\n        },\n        \"%V\": (y) => {\n          var P = Math.floor((y.tm_yday + 7 - (y.tm_wday + 6) % 7) / 7);\n          if ((y.tm_wday + 371 - y.tm_yday - 2) % 7 <= 2 && P++, P) {\n            if (P == 53) {\n              var z = (y.tm_wday + 371 - y.tm_yday) % 7;\n              z != 4 && (z != 3 || !et(y.tm_year)) && (P = 1);\n            }\n          } else {\n            P = 52;\n            var q = (y.tm_wday + 7 - y.tm_yday - 1) % 7;\n            (q == 4 || q == 5 && et(y.tm_year % 400 - 1)) && P++;\n          }\n          return E(P, 2);\n        },\n        \"%w\": (y) => y.tm_wday,\n        \"%W\": (y) => {\n          var P = y.tm_yday + 7 - (y.tm_wday + 6) % 7;\n          return E(Math.floor(P / 7), 2);\n        },\n        \"%y\": (y) => (y.tm_year + 1900).toString().substring(2),\n        \"%Y\": (y) => y.tm_year + 1900,\n        \"%z\": (y) => {\n          var P = y.tm_gmtoff, z = P >= 0;\n          return P = Math.abs(P) / 60, P = P / 60 * 100 + P % 60, (z ? \"+\" : \"-\") + (\"0000\" + P).slice(-4);\n        },\n        \"%Z\": (y) => y.tm_zone,\n        \"%%\": () => \"%\"\n      };\n      l = l.replace(/%%/g, \"\\0\\0\");\n      for (var m in I)\n        l.includes(m) && (l = l.replace(new RegExp(m, \"g\"), I[m](u)));\n      l = l.replace(/\\0\\0/g, \"%\");\n      var J = Ha(l, !1);\n      return J.length > t ? 0 : (Ba(J, e), J.length - 1);\n    }, Na = (e, t, n, a, s) => Va(e, t, n, a);\n    zt = i.InternalError = class extends Error {\n      constructor(e) {\n        super(e), this.name = \"InternalError\";\n      }\n    }, vn(), _e = i.BindingError = class extends Error {\n      constructor(e) {\n        super(e), this.name = \"BindingError\";\n      }\n    }, On(), Sn(), Fn(), tr = i.UnboundTypeError = Ln(Error, \"UnboundTypeError\"), zn(), qn();\n    var za = {\n      s: an,\n      u: on,\n      b: cn,\n      g: un,\n      q: ln,\n      J: dn,\n      f: fn,\n      V: hn,\n      d: sn,\n      da: pn,\n      Q: mn,\n      _: gn,\n      ca: Hn,\n      ba: Vn,\n      w: Nn,\n      Y: Yn,\n      x: Qn,\n      h: Xn,\n      L: Kn,\n      M: ea,\n      t: ra,\n      o: na,\n      K: ia,\n      C: ha,\n      A: pa,\n      ea: ma,\n      $: va,\n      R: ya,\n      ha: At,\n      fa: ba,\n      Z: Pa,\n      N: Ta,\n      O: Ea,\n      aa: Oa,\n      B: Ma,\n      X: Aa,\n      W: xa,\n      T: Fa,\n      U: Ua,\n      E: so,\n      D: Qa,\n      F: io,\n      n: co,\n      a: Ga,\n      e: Za,\n      m: Ja,\n      k: eo,\n      H: ao,\n      v: ro,\n      G: oo,\n      z: lo,\n      P: ho,\n      l: Ka,\n      j: Xa,\n      c: Ya,\n      p: qa,\n      I: no,\n      r: uo,\n      i: to,\n      y: fo,\n      ga: Wa,\n      S: Na\n    }, G = nn(), ce = i._free = (e) => (ce = i._free = G.ka)(e), Ft = i._malloc = (e) => (Ft = i._malloc = G.la)(e), fr = (e) => (fr = G.na)(e), j = (e, t) => (j = G.oa)(e, t), Ue = (e) => (Ue = G.pa)(e), B = () => (B = G.qa)(), V = (e) => (V = G.ra)(e), hr = (e) => (hr = G.sa)(e), pr = (e) => (pr = G.ta)(e), mr = (e, t, n) => (mr = G.ua)(e, t, n), vr = (e) => (vr = G.va)(e);\n    i.dynCall_viijii = (e, t, n, a, s, u, l) => (i.dynCall_viijii = G.wa)(e, t, n, a, s, u, l);\n    var yr = i.dynCall_jiiii = (e, t, n, a, s) => (yr = i.dynCall_jiiii = G.xa)(e, t, n, a, s);\n    i.dynCall_iiiiij = (e, t, n, a, s, u, l) => (i.dynCall_iiiiij = G.ya)(e, t, n, a, s, u, l), i.dynCall_iiiiijj = (e, t, n, a, s, u, l, f, m) => (i.dynCall_iiiiijj = G.za)(e, t, n, a, s, u, l, f, m), i.dynCall_iiiiiijj = (e, t, n, a, s, u, l, f, m, w) => (i.dynCall_iiiiiijj = G.Aa)(e, t, n, a, s, u, l, f, m, w);\n    function Ga(e, t) {\n      var n = B();\n      try {\n        return H(e)(t);\n      } catch (a) {\n        if (V(n), a !== a + 0)\n          throw a;\n        j(1, 0);\n      }\n    }\n    function qa(e, t, n, a) {\n      var s = B();\n      try {\n        H(e)(t, n, a);\n      } catch (u) {\n        if (V(s), u !== u + 0)\n          throw u;\n        j(1, 0);\n      }\n    }\n    function Ya(e, t, n) {\n      var a = B();\n      try {\n        H(e)(t, n);\n      } catch (s) {\n        if (V(a), s !== s + 0)\n          throw s;\n        j(1, 0);\n      }\n    }\n    function Ja(e, t, n, a) {\n      var s = B();\n      try {\n        return H(e)(t, n, a);\n      } catch (u) {\n        if (V(s), u !== u + 0)\n          throw u;\n        j(1, 0);\n      }\n    }\n    function Qa(e, t, n, a, s) {\n      var u = B();\n      try {\n        return H(e)(t, n, a, s);\n      } catch (l) {\n        if (V(u), l !== l + 0)\n          throw l;\n        j(1, 0);\n      }\n    }\n    function Xa(e, t) {\n      var n = B();\n      try {\n        H(e)(t);\n      } catch (a) {\n        if (V(n), a !== a + 0)\n          throw a;\n        j(1, 0);\n      }\n    }\n    function Za(e, t, n) {\n      var a = B();\n      try {\n        return H(e)(t, n);\n      } catch (s) {\n        if (V(a), s !== s + 0)\n          throw s;\n        j(1, 0);\n      }\n    }\n    function Ka(e) {\n      var t = B();\n      try {\n        H(e)();\n      } catch (n) {\n        if (V(t), n !== n + 0)\n          throw n;\n        j(1, 0);\n      }\n    }\n    function eo(e, t, n, a, s) {\n      var u = B();\n      try {\n        return H(e)(t, n, a, s);\n      } catch (l) {\n        if (V(u), l !== l + 0)\n          throw l;\n        j(1, 0);\n      }\n    }\n    function to(e, t, n, a, s, u, l, f, m, w, _) {\n      var T = B();\n      try {\n        H(e)(t, n, a, s, u, l, f, m, w, _);\n      } catch (E) {\n        if (V(T), E !== E + 0)\n          throw E;\n        j(1, 0);\n      }\n    }\n    function ro(e, t, n, a, s, u, l) {\n      var f = B();\n      try {\n        return H(e)(t, n, a, s, u, l);\n      } catch (m) {\n        if (V(f), m !== m + 0)\n          throw m;\n        j(1, 0);\n      }\n    }\n    function no(e, t, n, a, s) {\n      var u = B();\n      try {\n        H(e)(t, n, a, s);\n      } catch (l) {\n        if (V(u), l !== l + 0)\n          throw l;\n        j(1, 0);\n      }\n    }\n    function ao(e, t, n, a, s, u) {\n      var l = B();\n      try {\n        return H(e)(t, n, a, s, u);\n      } catch (f) {\n        if (V(l), f !== f + 0)\n          throw f;\n        j(1, 0);\n      }\n    }\n    function oo(e, t, n, a, s, u, l, f) {\n      var m = B();\n      try {\n        return H(e)(t, n, a, s, u, l, f);\n      } catch (w) {\n        if (V(m), w !== w + 0)\n          throw w;\n        j(1, 0);\n      }\n    }\n    function io(e, t, n, a) {\n      var s = B();\n      try {\n        return H(e)(t, n, a);\n      } catch (u) {\n        if (V(s), u !== u + 0)\n          throw u;\n        j(1, 0);\n      }\n    }\n    function so(e, t, n, a) {\n      var s = B();\n      try {\n        return H(e)(t, n, a);\n      } catch (u) {\n        if (V(s), u !== u + 0)\n          throw u;\n        j(1, 0);\n      }\n    }\n    function co(e) {\n      var t = B();\n      try {\n        return H(e)();\n      } catch (n) {\n        if (V(t), n !== n + 0)\n          throw n;\n        j(1, 0);\n      }\n    }\n    function uo(e, t, n, a, s, u, l, f) {\n      var m = B();\n      try {\n        H(e)(t, n, a, s, u, l, f);\n      } catch (w) {\n        if (V(m), w !== w + 0)\n          throw w;\n        j(1, 0);\n      }\n    }\n    function lo(e, t, n, a, s, u, l, f, m, w, _, T) {\n      var E = B();\n      try {\n        return H(e)(t, n, a, s, u, l, f, m, w, _, T);\n      } catch (O) {\n        if (V(E), O !== O + 0)\n          throw O;\n        j(1, 0);\n      }\n    }\n    function fo(e, t, n, a, s, u, l, f, m, w, _, T, E, O, L, N) {\n      var I = B();\n      try {\n        H(e)(t, n, a, s, u, l, f, m, w, _, T, E, O, L, N);\n      } catch (J) {\n        if (V(I), J !== J + 0)\n          throw J;\n        j(1, 0);\n      }\n    }\n    function ho(e, t, n, a, s) {\n      var u = B();\n      try {\n        return yr(e, t, n, a, s);\n      } catch (l) {\n        if (V(u), l !== l + 0)\n          throw l;\n        j(1, 0);\n      }\n    }\n    var tt;\n    ve = function e() {\n      tt || gr(), tt || (ve = e);\n    };\n    function gr() {\n      if (te > 0 || (Le(), te > 0))\n        return;\n      function e() {\n        tt || (tt = !0, i.calledRun = !0, !W && (dt(), c(i), i.onRuntimeInitialized && i.onRuntimeInitialized(), ft()));\n      }\n      i.setStatus ? (i.setStatus(\"Running...\"), setTimeout(function() {\n        setTimeout(function() {\n          i.setStatus(\"\");\n        }, 1), e();\n      }, 1)) : e();\n    }\n    if (i.preInit)\n      for (typeof i.preInit == \"function\" && (i.preInit = [i.preInit]); i.preInit.length > 0; )\n        i.preInit.pop()();\n    return gr(), o.ready;\n  };\n})();\nfunction Go(r) {\n  return Vt(\n    ut,\n    r\n  );\n}\nfunction ji(r) {\n  return Vo(\n    ut,\n    r\n  );\n}\nasync function qo(r, o) {\n  return No(\n    ut,\n    r,\n    o\n  );\n}\nasync function Yo(r, o) {\n  return zo(\n    ut,\n    r,\n    o\n  );\n}\nvar je;\nclass lt extends EventTarget {\n  constructor(o = {}) {\n    var i;\n    super(), wo(this, je, void 0);\n    try {\n      const c = (i = o == null ? void 0 : o.formats) == null ? void 0 : i.filter(\n        (d) => d !== \"unknown\"\n      );\n      if ((c == null ? void 0 : c.length) === 0)\n        throw new TypeError(\"Hint option provided, but is empty.\");\n      c == null || c.forEach((d) => {\n        if (!it.has(d))\n          throw new TypeError(\n            `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${d}' is not a valid enum value of type BarcodeFormat.`\n          );\n      }), bo(this, je, c != null ? c : []), Go().then((d) => {\n        this.dispatchEvent(\n          new CustomEvent(\"load\", {\n            detail: d\n          })\n        );\n      }).catch((d) => {\n        this.dispatchEvent(new CustomEvent(\"error\", { detail: d }));\n      });\n    } catch (c) {\n      throw $r(\n        c,\n        \"Failed to construct 'BarcodeDetector'\"\n      );\n    }\n  }\n  static async getSupportedFormats() {\n    return Co.filter((o) => o !== \"unknown\");\n  }\n  async detect(o) {\n    try {\n      const i = await Oo(o);\n      if (i === null)\n        return [];\n      let c;\n      try {\n        jr(i) ? c = await qo(i, {\n          tryHarder: !0,\n          formats: Cr(this, je).map((d) => it.get(d))\n        }) : c = await Yo(i, {\n          tryHarder: !0,\n          formats: Cr(this, je).map((d) => it.get(d))\n        });\n      } catch (d) {\n        throw console.error(d), new DOMException(\n          \"Barcode detection service unavailable.\",\n          \"NotSupportedError\"\n        );\n      }\n      return c.map((d) => {\n        const {\n          topLeft: { x: h, y: v },\n          topRight: { x: g, y: b },\n          bottomLeft: { x: p, y: C },\n          bottomRight: { x: S, y: $ }\n        } = d.position, F = Math.min(h, g, p, S), U = Math.min(v, b, C, $), W = Math.max(h, g, p, S), x = Math.max(v, b, C, $);\n        return {\n          boundingBox: new DOMRectReadOnly(\n            F,\n            U,\n            W - F,\n            x - U\n          ),\n          rawValue: d.text,\n          format: $o(d.format),\n          cornerPoints: [\n            {\n              x: h,\n              y: v\n            },\n            {\n              x: g,\n              y: b\n            },\n            {\n              x: S,\n              y: $\n            },\n            {\n              x: p,\n              y: C\n            }\n          ]\n        };\n      });\n    } catch (i) {\n      throw $r(\n        i,\n        \"Failed to execute 'detect' on 'BarcodeDetector'\"\n      );\n    }\n  }\n}\nje = /* @__PURE__ */ new WeakMap();\nconst Nt = (r, o, i = \"error\") => {\n  let c, d;\n  const h = new Promise(\n    (v, g) => {\n      c = v, d = g, r.addEventListener(o, c), r.addEventListener(i, d);\n    }\n  );\n  return h.finally(() => {\n    r.removeEventListener(o, c), r.removeEventListener(i, d);\n  }), h;\n}, Pr = (r) => new Promise((o) => setTimeout(o, r));\nclass Jo extends Error {\n  constructor() {\n    super(\"can't process cross-origin image\"), this.name = \"DropImageFetchError\";\n  }\n}\nclass Vr extends Error {\n  constructor() {\n    super(\"this browser has no Stream API support\"), this.name = \"StreamApiNotSupportedError\";\n  }\n}\nclass Qo extends Error {\n  constructor() {\n    super(\n      \"camera access is only permitted in secure context. Use HTTPS or localhost rather than HTTP.\"\n    ), this.name = \"InsecureContextError\";\n  }\n}\nclass Xo extends Error {\n  constructor() {\n    super(\n      \"Loading camera stream timed out after 3 seconds. If you are on iOS in PWA mode, this is a known issue (see https://github.com/gruhn/vue-qrcode-reader/issues/298)\"\n    ), this.name = \"StreamLoadTimeoutError\";\n  }\n}\nlet jt;\nconst Zo = (r) => {\n  jt = new lt({ formats: r });\n}, Ko = async (r, {\n  detectHandler: o,\n  locateHandler: i,\n  minDelay: c,\n  formats: d\n}) => {\n  jt = new lt({ formats: d });\n  const h = (v) => async (g) => {\n    if (r.readyState > 1) {\n      const { lastScanned: b, contentBefore: p, lastScanHadContent: C } = v;\n      if (g - b < c)\n        window.requestAnimationFrame(h(v));\n      else {\n        const S = await jt.detect(r), $ = S.some((W) => !p.includes(W.rawValue));\n        $ && o(S);\n        const F = S.length > 0;\n        F && i(S), !F && C && i(S);\n        const U = {\n          lastScanned: g,\n          lastScanHadContent: F,\n          // It can happen that a QR code is constantly in view of the camera but\n          // maybe a scanned frame is a bit blurry and we detect nothing but in the\n          // next frame we detect the code again. We also want to avoid emitting\n          // a `detect` event in such a case. So we don't reset `contentBefore`,\n          // if we detect nothing, only if we detect something new.\n          contentBefore: $ ? S.map((W) => W.rawValue) : p\n        };\n        window.requestAnimationFrame(h(U));\n      }\n    }\n  };\n  h({\n    lastScanned: performance.now(),\n    contentBefore: [],\n    lastScanHadContent: !1\n  })(performance.now());\n}, ei = async (r) => {\n  if (r.startsWith(\"http\") && r.includes(location.host) === !1)\n    throw new Jo();\n  const o = document.createElement(\"img\");\n  return o.src = r, await Nt(o, \"load\"), o;\n}, Nr = async (r, o = [\"qr_code\"]) => await new lt({\n  formats: o\n}).detect(r), ti = async (r, o = [\"qr_code\"]) => {\n  const i = new lt({\n    formats: o\n  }), c = await ei(r);\n  return await i.detect(c);\n};\nvar zr = {}, Q = {};\nObject.defineProperty(Q, \"__esModule\", {\n  value: !0\n});\nQ.compactObject = Yr;\nQ.deprecated = li;\nvar ri = Q.detectBrowser = di;\nQ.disableLog = si;\nQ.disableWarnings = ci;\nQ.extractVersion = st;\nQ.filterStats = fi;\nQ.log = ui;\nQ.walkStats = ct;\nQ.wrapPeerConnectionEvent = ii;\nfunction ni(r, o, i) {\n  return o = ai(o), o in r ? Object.defineProperty(r, o, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[o] = i, r;\n}\nfunction ai(r) {\n  var o = oi(r, \"string\");\n  return pe(o) === \"symbol\" ? o : String(o);\n}\nfunction oi(r, o) {\n  if (pe(r) !== \"object\" || r === null)\n    return r;\n  var i = r[Symbol.toPrimitive];\n  if (i !== void 0) {\n    var c = i.call(r, o || \"default\");\n    if (pe(c) !== \"object\")\n      return c;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (o === \"string\" ? String : Number)(r);\n}\nfunction pe(r) {\n  \"@babel/helpers - typeof\";\n  return pe = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n    return typeof o;\n  } : function(o) {\n    return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, pe(r);\n}\nvar Gr = !0, qr = !0;\nfunction st(r, o, i) {\n  var c = r.match(o);\n  return c && c.length >= i && parseInt(c[i], 10);\n}\nfunction ii(r, o, i) {\n  if (r.RTCPeerConnection) {\n    var c = r.RTCPeerConnection.prototype, d = c.addEventListener;\n    c.addEventListener = function(v, g) {\n      if (v !== o)\n        return d.apply(this, arguments);\n      var b = function(C) {\n        var S = i(C);\n        S && (g.handleEvent ? g.handleEvent(S) : g(S));\n      };\n      return this._eventMap = this._eventMap || {}, this._eventMap[o] || (this._eventMap[o] = /* @__PURE__ */ new Map()), this._eventMap[o].set(g, b), d.apply(this, [v, b]);\n    };\n    var h = c.removeEventListener;\n    c.removeEventListener = function(v, g) {\n      if (v !== o || !this._eventMap || !this._eventMap[o])\n        return h.apply(this, arguments);\n      if (!this._eventMap[o].has(g))\n        return h.apply(this, arguments);\n      var b = this._eventMap[o].get(g);\n      return this._eventMap[o].delete(g), this._eventMap[o].size === 0 && delete this._eventMap[o], Object.keys(this._eventMap).length === 0 && delete this._eventMap, h.apply(this, [v, b]);\n    }, Object.defineProperty(c, \"on\" + o, {\n      get: function() {\n        return this[\"_on\" + o];\n      },\n      set: function(g) {\n        this[\"_on\" + o] && (this.removeEventListener(o, this[\"_on\" + o]), delete this[\"_on\" + o]), g && this.addEventListener(o, this[\"_on\" + o] = g);\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  }\n}\nfunction si(r) {\n  return typeof r != \"boolean\" ? new Error(\"Argument type: \" + pe(r) + \". Please use a boolean.\") : (Gr = r, r ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n}\nfunction ci(r) {\n  return typeof r != \"boolean\" ? new Error(\"Argument type: \" + pe(r) + \". Please use a boolean.\") : (qr = !r, \"adapter.js deprecation warnings \" + (r ? \"disabled\" : \"enabled\"));\n}\nfunction ui() {\n  if ((typeof window > \"u\" ? \"undefined\" : pe(window)) === \"object\") {\n    if (Gr)\n      return;\n    typeof console < \"u\" && typeof console.log == \"function\" && console.log.apply(console, arguments);\n  }\n}\nfunction li(r, o) {\n  qr && console.warn(r + \" is deprecated, please use \" + o + \" instead.\");\n}\nfunction di(r) {\n  var o = {\n    browser: null,\n    version: null\n  };\n  if (typeof r > \"u\" || !r.navigator || !r.navigator.userAgent)\n    return o.browser = \"Not a browser.\", o;\n  var i = r.navigator;\n  if (i.mozGetUserMedia)\n    o.browser = \"firefox\", o.version = st(i.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  else if (i.webkitGetUserMedia || r.isSecureContext === !1 && r.webkitRTCPeerConnection)\n    o.browser = \"chrome\", o.version = st(i.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  else if (r.RTCPeerConnection && i.userAgent.match(/AppleWebKit\\/(\\d+)\\./))\n    o.browser = \"safari\", o.version = st(i.userAgent, /AppleWebKit\\/(\\d+)\\./, 1), o.supportsUnifiedPlan = r.RTCRtpTransceiver && \"currentDirection\" in r.RTCRtpTransceiver.prototype;\n  else\n    return o.browser = \"Not a supported browser.\", o;\n  return o;\n}\nfunction Tr(r) {\n  return Object.prototype.toString.call(r) === \"[object Object]\";\n}\nfunction Yr(r) {\n  return Tr(r) ? Object.keys(r).reduce(function(o, i) {\n    var c = Tr(r[i]), d = c ? Yr(r[i]) : r[i], h = c && !Object.keys(d).length;\n    return d === void 0 || h ? o : Object.assign(o, ni({}, i, d));\n  }, {}) : r;\n}\nfunction ct(r, o, i) {\n  !o || i.has(o.id) || (i.set(o.id, o), Object.keys(o).forEach(function(c) {\n    c.endsWith(\"Id\") ? ct(r, r.get(o[c]), i) : c.endsWith(\"Ids\") && o[c].forEach(function(d) {\n      ct(r, r.get(d), i);\n    });\n  }));\n}\nfunction fi(r, o, i) {\n  var c = i ? \"outbound-rtp\" : \"inbound-rtp\", d = /* @__PURE__ */ new Map();\n  if (o === null)\n    return d;\n  var h = [];\n  return r.forEach(function(v) {\n    v.type === \"track\" && v.trackIdentifier === o.id && h.push(v);\n  }), h.forEach(function(v) {\n    r.forEach(function(g) {\n      g.type === c && g.trackId === v.id && ct(r, g, d);\n    });\n  }), d;\n}\nObject.defineProperty(zr, \"__esModule\", {\n  value: !0\n});\nvar hi = zr.shimGetUserMedia = vi, pi = mi(Q);\nfunction Jr(r) {\n  if (typeof WeakMap != \"function\")\n    return null;\n  var o = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();\n  return (Jr = function(d) {\n    return d ? i : o;\n  })(r);\n}\nfunction mi(r, o) {\n  if (!o && r && r.__esModule)\n    return r;\n  if (r === null || he(r) !== \"object\" && typeof r != \"function\")\n    return { default: r };\n  var i = Jr(o);\n  if (i && i.has(r))\n    return i.get(r);\n  var c = {}, d = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var h in r)\n    if (h !== \"default\" && Object.prototype.hasOwnProperty.call(r, h)) {\n      var v = d ? Object.getOwnPropertyDescriptor(r, h) : null;\n      v && (v.get || v.set) ? Object.defineProperty(c, h, v) : c[h] = r[h];\n    }\n  return c.default = r, i && i.set(r, c), c;\n}\nfunction he(r) {\n  \"@babel/helpers - typeof\";\n  return he = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n    return typeof o;\n  } : function(o) {\n    return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, he(r);\n}\nvar Er = pi.log;\nfunction vi(r, o) {\n  var i = r && r.navigator;\n  if (i.mediaDevices) {\n    var c = function(p) {\n      if (he(p) !== \"object\" || p.mandatory || p.optional)\n        return p;\n      var C = {};\n      return Object.keys(p).forEach(function(S) {\n        if (!(S === \"require\" || S === \"advanced\" || S === \"mediaSource\")) {\n          var $ = he(p[S]) === \"object\" ? p[S] : {\n            ideal: p[S]\n          };\n          $.exact !== void 0 && typeof $.exact == \"number\" && ($.min = $.max = $.exact);\n          var F = function(x, D) {\n            return x ? x + D.charAt(0).toUpperCase() + D.slice(1) : D === \"deviceId\" ? \"sourceId\" : D;\n          };\n          if ($.ideal !== void 0) {\n            C.optional = C.optional || [];\n            var U = {};\n            typeof $.ideal == \"number\" ? (U[F(\"min\", S)] = $.ideal, C.optional.push(U), U = {}, U[F(\"max\", S)] = $.ideal, C.optional.push(U)) : (U[F(\"\", S)] = $.ideal, C.optional.push(U));\n          }\n          $.exact !== void 0 && typeof $.exact != \"number\" ? (C.mandatory = C.mandatory || {}, C.mandatory[F(\"\", S)] = $.exact) : [\"min\", \"max\"].forEach(function(W) {\n            $[W] !== void 0 && (C.mandatory = C.mandatory || {}, C.mandatory[F(W, S)] = $[W]);\n          });\n        }\n      }), p.advanced && (C.optional = (C.optional || []).concat(p.advanced)), C;\n    }, d = function(p, C) {\n      if (o.version >= 61)\n        return C(p);\n      if (p = JSON.parse(JSON.stringify(p)), p && he(p.audio) === \"object\") {\n        var S = function(x, D, X) {\n          D in x && !(X in x) && (x[X] = x[D], delete x[D]);\n        };\n        p = JSON.parse(JSON.stringify(p)), S(p.audio, \"autoGainControl\", \"googAutoGainControl\"), S(p.audio, \"noiseSuppression\", \"googNoiseSuppression\"), p.audio = c(p.audio);\n      }\n      if (p && he(p.video) === \"object\") {\n        var $ = p.video.facingMode;\n        $ = $ && (he($) === \"object\" ? $ : {\n          ideal: $\n        });\n        var F = o.version < 66;\n        if ($ && ($.exact === \"user\" || $.exact === \"environment\" || $.ideal === \"user\" || $.ideal === \"environment\") && !(i.mediaDevices.getSupportedConstraints && i.mediaDevices.getSupportedConstraints().facingMode && !F)) {\n          delete p.video.facingMode;\n          var U;\n          if ($.exact === \"environment\" || $.ideal === \"environment\" ? U = [\"back\", \"rear\"] : ($.exact === \"user\" || $.ideal === \"user\") && (U = [\"front\"]), U)\n            return i.mediaDevices.enumerateDevices().then(function(W) {\n              W = W.filter(function(D) {\n                return D.kind === \"videoinput\";\n              });\n              var x = W.find(function(D) {\n                return U.some(function(X) {\n                  return D.label.toLowerCase().includes(X);\n                });\n              });\n              return !x && W.length && U.includes(\"back\") && (x = W[W.length - 1]), x && (p.video.deviceId = $.exact ? {\n                exact: x.deviceId\n              } : {\n                ideal: x.deviceId\n              }), p.video = c(p.video), Er(\"chrome: \" + JSON.stringify(p)), C(p);\n            });\n        }\n        p.video = c(p.video);\n      }\n      return Er(\"chrome: \" + JSON.stringify(p)), C(p);\n    }, h = function(p) {\n      return o.version >= 64 ? p : {\n        name: {\n          PermissionDeniedError: \"NotAllowedError\",\n          PermissionDismissedError: \"NotAllowedError\",\n          InvalidStateError: \"NotAllowedError\",\n          DevicesNotFoundError: \"NotFoundError\",\n          ConstraintNotSatisfiedError: \"OverconstrainedError\",\n          TrackStartError: \"NotReadableError\",\n          MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n          MediaDeviceKillSwitchOn: \"NotAllowedError\",\n          TabCaptureError: \"AbortError\",\n          ScreenCaptureError: \"AbortError\",\n          DeviceCaptureError: \"AbortError\"\n        }[p.name] || p.name,\n        message: p.message,\n        constraint: p.constraint || p.constraintName,\n        toString: function() {\n          return this.name + (this.message && \": \") + this.message;\n        }\n      };\n    }, v = function(p, C, S) {\n      d(p, function($) {\n        i.webkitGetUserMedia($, C, function(F) {\n          S && S(h(F));\n        });\n      });\n    };\n    if (i.getUserMedia = v.bind(i), i.mediaDevices.getUserMedia) {\n      var g = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n      i.mediaDevices.getUserMedia = function(b) {\n        return d(b, function(p) {\n          return g(p).then(function(C) {\n            if (p.audio && !C.getAudioTracks().length || p.video && !C.getVideoTracks().length)\n              throw C.getTracks().forEach(function(S) {\n                S.stop();\n              }), new DOMException(\"\", \"NotFoundError\");\n            return C;\n          }, function(C) {\n            return Promise.reject(h(C));\n          });\n        });\n      };\n    }\n  }\n}\nvar Qr = {};\nObject.defineProperty(Qr, \"__esModule\", {\n  value: !0\n});\nvar yi = Qr.shimGetUserMedia = bi, gi = wi(Q);\nfunction Xr(r) {\n  if (typeof WeakMap != \"function\")\n    return null;\n  var o = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();\n  return (Xr = function(d) {\n    return d ? i : o;\n  })(r);\n}\nfunction wi(r, o) {\n  if (!o && r && r.__esModule)\n    return r;\n  if (r === null || Pe(r) !== \"object\" && typeof r != \"function\")\n    return { default: r };\n  var i = Xr(o);\n  if (i && i.has(r))\n    return i.get(r);\n  var c = {}, d = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var h in r)\n    if (h !== \"default\" && Object.prototype.hasOwnProperty.call(r, h)) {\n      var v = d ? Object.getOwnPropertyDescriptor(r, h) : null;\n      v && (v.get || v.set) ? Object.defineProperty(c, h, v) : c[h] = r[h];\n    }\n  return c.default = r, i && i.set(r, c), c;\n}\nfunction Pe(r) {\n  \"@babel/helpers - typeof\";\n  return Pe = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n    return typeof o;\n  } : function(o) {\n    return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, Pe(r);\n}\nfunction bi(r, o) {\n  var i = r && r.navigator, c = r && r.MediaStreamTrack;\n  if (i.getUserMedia = function(b, p, C) {\n    gi.deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\"), i.mediaDevices.getUserMedia(b).then(p, C);\n  }, !(o.version > 55 && \"autoGainControl\" in i.mediaDevices.getSupportedConstraints())) {\n    var d = function(p, C, S) {\n      C in p && !(S in p) && (p[S] = p[C], delete p[C]);\n    }, h = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n    if (i.mediaDevices.getUserMedia = function(b) {\n      return Pe(b) === \"object\" && Pe(b.audio) === \"object\" && (b = JSON.parse(JSON.stringify(b)), d(b.audio, \"autoGainControl\", \"mozAutoGainControl\"), d(b.audio, \"noiseSuppression\", \"mozNoiseSuppression\")), h(b);\n    }, c && c.prototype.getSettings) {\n      var v = c.prototype.getSettings;\n      c.prototype.getSettings = function() {\n        var b = v.apply(this, arguments);\n        return d(b, \"mozAutoGainControl\", \"autoGainControl\"), d(b, \"mozNoiseSuppression\", \"noiseSuppression\"), b;\n      };\n    }\n    if (c && c.prototype.applyConstraints) {\n      var g = c.prototype.applyConstraints;\n      c.prototype.applyConstraints = function(b) {\n        return this.kind === \"audio\" && Pe(b) === \"object\" && (b = JSON.parse(JSON.stringify(b)), d(b, \"autoGainControl\", \"mozAutoGainControl\"), d(b, \"noiseSuppression\", \"mozNoiseSuppression\")), g.apply(this, [b]);\n      };\n    }\n  }\n}\nvar ae = {};\nObject.defineProperty(ae, \"__esModule\", {\n  value: !0\n});\nae.shimAudioContext = Ai;\nae.shimCallbacksAPI = Pi;\nae.shimConstraints = en;\nae.shimCreateOfferLegacy = Mi;\nvar Ci = ae.shimGetUserMedia = Ti;\nae.shimLocalStreamsAPI = _i;\nae.shimRTCIceServerUrls = Ei;\nae.shimRemoteStreamsAPI = Si;\nae.shimTrackEventTransceiver = Oi;\nvar Zr = $i(Q);\nfunction Kr(r) {\n  if (typeof WeakMap != \"function\")\n    return null;\n  var o = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();\n  return (Kr = function(d) {\n    return d ? i : o;\n  })(r);\n}\nfunction $i(r, o) {\n  if (!o && r && r.__esModule)\n    return r;\n  if (r === null || me(r) !== \"object\" && typeof r != \"function\")\n    return { default: r };\n  var i = Kr(o);\n  if (i && i.has(r))\n    return i.get(r);\n  var c = {}, d = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var h in r)\n    if (h !== \"default\" && Object.prototype.hasOwnProperty.call(r, h)) {\n      var v = d ? Object.getOwnPropertyDescriptor(r, h) : null;\n      v && (v.get || v.set) ? Object.defineProperty(c, h, v) : c[h] = r[h];\n    }\n  return c.default = r, i && i.set(r, c), c;\n}\nfunction me(r) {\n  \"@babel/helpers - typeof\";\n  return me = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o) {\n    return typeof o;\n  } : function(o) {\n    return o && typeof Symbol == \"function\" && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, me(r);\n}\nfunction _i(r) {\n  if (!(me(r) !== \"object\" || !r.RTCPeerConnection)) {\n    if (\"getLocalStreams\" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getLocalStreams = function() {\n      return this._localStreams || (this._localStreams = []), this._localStreams;\n    }), !(\"addStream\" in r.RTCPeerConnection.prototype)) {\n      var o = r.RTCPeerConnection.prototype.addTrack;\n      r.RTCPeerConnection.prototype.addStream = function(c) {\n        var d = this;\n        this._localStreams || (this._localStreams = []), this._localStreams.includes(c) || this._localStreams.push(c), c.getAudioTracks().forEach(function(h) {\n          return o.call(d, h, c);\n        }), c.getVideoTracks().forEach(function(h) {\n          return o.call(d, h, c);\n        });\n      }, r.RTCPeerConnection.prototype.addTrack = function(c) {\n        for (var d = this, h = arguments.length, v = new Array(h > 1 ? h - 1 : 0), g = 1; g < h; g++)\n          v[g - 1] = arguments[g];\n        return v && v.forEach(function(b) {\n          d._localStreams ? d._localStreams.includes(b) || d._localStreams.push(b) : d._localStreams = [b];\n        }), o.apply(this, arguments);\n      };\n    }\n    \"removeStream\" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.removeStream = function(c) {\n      var d = this;\n      this._localStreams || (this._localStreams = []);\n      var h = this._localStreams.indexOf(c);\n      if (h !== -1) {\n        this._localStreams.splice(h, 1);\n        var v = c.getTracks();\n        this.getSenders().forEach(function(g) {\n          v.includes(g.track) && d.removeTrack(g);\n        });\n      }\n    });\n  }\n}\nfunction Si(r) {\n  if (!(me(r) !== \"object\" || !r.RTCPeerConnection) && (\"getRemoteStreams\" in r.RTCPeerConnection.prototype || (r.RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this._remoteStreams ? this._remoteStreams : [];\n  }), !(\"onaddstream\" in r.RTCPeerConnection.prototype))) {\n    Object.defineProperty(r.RTCPeerConnection.prototype, \"onaddstream\", {\n      get: function() {\n        return this._onaddstream;\n      },\n      set: function(c) {\n        var d = this;\n        this._onaddstream && (this.removeEventListener(\"addstream\", this._onaddstream), this.removeEventListener(\"track\", this._onaddstreampoly)), this.addEventListener(\"addstream\", this._onaddstream = c), this.addEventListener(\"track\", this._onaddstreampoly = function(h) {\n          h.streams.forEach(function(v) {\n            if (d._remoteStreams || (d._remoteStreams = []), !d._remoteStreams.includes(v)) {\n              d._remoteStreams.push(v);\n              var g = new Event(\"addstream\");\n              g.stream = v, d.dispatchEvent(g);\n            }\n          });\n        });\n      }\n    });\n    var o = r.RTCPeerConnection.prototype.setRemoteDescription;\n    r.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      var c = this;\n      return this._onaddstreampoly || this.addEventListener(\"track\", this._onaddstreampoly = function(d) {\n        d.streams.forEach(function(h) {\n          if (c._remoteStreams || (c._remoteStreams = []), !(c._remoteStreams.indexOf(h) >= 0)) {\n            c._remoteStreams.push(h);\n            var v = new Event(\"addstream\");\n            v.stream = h, c.dispatchEvent(v);\n          }\n        });\n      }), o.apply(c, arguments);\n    };\n  }\n}\nfunction Pi(r) {\n  if (!(me(r) !== \"object\" || !r.RTCPeerConnection)) {\n    var o = r.RTCPeerConnection.prototype, i = o.createOffer, c = o.createAnswer, d = o.setLocalDescription, h = o.setRemoteDescription, v = o.addIceCandidate;\n    o.createOffer = function(p, C) {\n      var S = arguments.length >= 2 ? arguments[2] : arguments[0], $ = i.apply(this, [S]);\n      return C ? ($.then(p, C), Promise.resolve()) : $;\n    }, o.createAnswer = function(p, C) {\n      var S = arguments.length >= 2 ? arguments[2] : arguments[0], $ = c.apply(this, [S]);\n      return C ? ($.then(p, C), Promise.resolve()) : $;\n    };\n    var g = function(p, C, S) {\n      var $ = d.apply(this, [p]);\n      return S ? ($.then(C, S), Promise.resolve()) : $;\n    };\n    o.setLocalDescription = g, g = function(p, C, S) {\n      var $ = h.apply(this, [p]);\n      return S ? ($.then(C, S), Promise.resolve()) : $;\n    }, o.setRemoteDescription = g, g = function(p, C, S) {\n      var $ = v.apply(this, [p]);\n      return S ? ($.then(C, S), Promise.resolve()) : $;\n    }, o.addIceCandidate = g;\n  }\n}\nfunction Ti(r) {\n  var o = r && r.navigator;\n  if (o.mediaDevices && o.mediaDevices.getUserMedia) {\n    var i = o.mediaDevices, c = i.getUserMedia.bind(i);\n    o.mediaDevices.getUserMedia = function(d) {\n      return c(en(d));\n    };\n  }\n  !o.getUserMedia && o.mediaDevices && o.mediaDevices.getUserMedia && (o.getUserMedia = (function(h, v, g) {\n    o.mediaDevices.getUserMedia(h).then(v, g);\n  }).bind(o));\n}\nfunction en(r) {\n  return r && r.video !== void 0 ? Object.assign({}, r, {\n    video: Zr.compactObject(r.video)\n  }) : r;\n}\nfunction Ei(r) {\n  if (r.RTCPeerConnection) {\n    var o = r.RTCPeerConnection;\n    r.RTCPeerConnection = function(c, d) {\n      if (c && c.iceServers) {\n        for (var h = [], v = 0; v < c.iceServers.length; v++) {\n          var g = c.iceServers[v];\n          g.urls === void 0 && g.url ? (Zr.deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\"), g = JSON.parse(JSON.stringify(g)), g.urls = g.url, delete g.url, h.push(g)) : h.push(c.iceServers[v]);\n        }\n        c.iceServers = h;\n      }\n      return new o(c, d);\n    }, r.RTCPeerConnection.prototype = o.prototype, \"generateCertificate\" in o && Object.defineProperty(r.RTCPeerConnection, \"generateCertificate\", {\n      get: function() {\n        return o.generateCertificate;\n      }\n    });\n  }\n}\nfunction Oi(r) {\n  me(r) === \"object\" && r.RTCTrackEvent && \"receiver\" in r.RTCTrackEvent.prototype && !(\"transceiver\" in r.RTCTrackEvent.prototype) && Object.defineProperty(r.RTCTrackEvent.prototype, \"transceiver\", {\n    get: function() {\n      return {\n        receiver: this.receiver\n      };\n    }\n  });\n}\nfunction Mi(r) {\n  var o = r.RTCPeerConnection.prototype.createOffer;\n  r.RTCPeerConnection.prototype.createOffer = function(c) {\n    if (c) {\n      typeof c.offerToReceiveAudio < \"u\" && (c.offerToReceiveAudio = !!c.offerToReceiveAudio);\n      var d = this.getTransceivers().find(function(v) {\n        return v.receiver.track.kind === \"audio\";\n      });\n      c.offerToReceiveAudio === !1 && d ? d.direction === \"sendrecv\" ? d.setDirection ? d.setDirection(\"sendonly\") : d.direction = \"sendonly\" : d.direction === \"recvonly\" && (d.setDirection ? d.setDirection(\"inactive\") : d.direction = \"inactive\") : c.offerToReceiveAudio === !0 && !d && this.addTransceiver(\"audio\", {\n        direction: \"recvonly\"\n      }), typeof c.offerToReceiveVideo < \"u\" && (c.offerToReceiveVideo = !!c.offerToReceiveVideo);\n      var h = this.getTransceivers().find(function(v) {\n        return v.receiver.track.kind === \"video\";\n      });\n      c.offerToReceiveVideo === !1 && h ? h.direction === \"sendrecv\" ? h.setDirection ? h.setDirection(\"sendonly\") : h.direction = \"sendonly\" : h.direction === \"recvonly\" && (h.setDirection ? h.setDirection(\"inactive\") : h.direction = \"inactive\") : c.offerToReceiveVideo === !0 && !h && this.addTransceiver(\"video\", {\n        direction: \"recvonly\"\n      });\n    }\n    return o.apply(this, arguments);\n  };\n}\nfunction Ai(r) {\n  me(r) !== \"object\" || r.AudioContext || (r.AudioContext = r.webkitAudioContext);\n}\nconst Di = (r) => {\n  let o = !1, i;\n  return (...c) => (o || (i = r(c), o = !0), i);\n};\nfunction ue(r, o) {\n  if (r === !1)\n    throw new Error(o != null ? o : \"assertion failure\");\n}\nconst Ri = Di(() => {\n  const r = ri(window);\n  switch (r.browser) {\n    case \"chrome\":\n      hi(window, r);\n      break;\n    case \"firefox\":\n      yi(window, r);\n      break;\n    case \"safari\":\n      Ci(window, r);\n      break;\n    default:\n      throw new Vr();\n  }\n});\nlet Te = Promise.resolve({ type: \"stop\", data: {} });\nasync function Or(r, o, i) {\n  var g, b, p;\n  if (window.isSecureContext !== !0)\n    throw new Qo();\n  if (((g = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : g.getUserMedia) === void 0)\n    throw new Vr();\n  Ri();\n  const c = await navigator.mediaDevices.getUserMedia({\n    audio: !1,\n    video: o\n  });\n  r.srcObject !== void 0 ? r.srcObject = c : r.mozSrcObject !== void 0 ? r.mozSrcObject = c : window.URL.createObjectURL ? r.src = window.URL.createObjectURL(c) : window.webkitURL ? r.src = window.webkitURL.createObjectURL(c) : r.src = c.id, r.play(), await Promise.race([\n    Nt(r, \"loadeddata\"),\n    // On iOS devices in PWA mode, QrcodeStream works initially, but after\n    // killing and restarting the PWA, all video elements fail to load camera\n    // streams and never emit the `loadeddata` event. Looks like this is\n    // related to a WebKit issue (see #298). No workarounds at the moment.\n    // To at least detect this situation, we throw an error if the event\n    // has not been emitted after a 3 second timeout.\n    Pr(3e3).then(() => {\n      throw new Xo();\n    })\n  ]), await Pr(500);\n  const [d] = c.getVideoTracks(), h = (p = (b = d == null ? void 0 : d.getCapabilities) == null ? void 0 : b.call(d)) != null ? p : {};\n  let v = !1;\n  return i && h.torch && (await d.applyConstraints({ advanced: [{ torch: !0 }] }), v = !0), {\n    type: \"start\",\n    data: {\n      videoEl: r,\n      stream: c,\n      capabilities: h,\n      constraints: o,\n      isTorchOn: v\n    }\n  };\n}\nasync function xi(r, {\n  constraints: o,\n  torch: i,\n  restart: c = !1\n}) {\n  Te = Te.then((h) => {\n    if (h.type === \"start\") {\n      const {\n        data: {\n          videoEl: v,\n          stream: g,\n          constraints: b,\n          isTorchOn: p\n        }\n      } = h;\n      return !c && r === v && o === b && i === p ? h : tn(v, g, p).then(\n        () => Or(r, o, i)\n      );\n    }\n    return Or(r, o, i);\n  });\n  const d = await Te;\n  if (d.type === \"stop\")\n    throw new Error(\"Something went wrong with the camera task queue (start task).\");\n  return d.data.capabilities;\n}\nasync function tn(r, o, i) {\n  r.src = \"\", r.srcObject = null, r.load(), await Nt(r, \"error\");\n  for (const c of o.getTracks())\n    i != null || await c.applyConstraints({ advanced: [{ torch: !1 }] }), o.removeTrack(c), c.stop();\n  return {\n    type: \"stop\",\n    data: {}\n  };\n}\nasync function ot() {\n  if (Te = Te.then((o) => {\n    if (o.type === \"stop\")\n      return o;\n    const {\n      data: { videoEl: i, stream: c, isTorchOn: d }\n    } = o;\n    return tn(i, c, d);\n  }), (await Te).type === \"start\")\n    throw new Error(\"Something went wrong with the camera task queue (stop task).\");\n}\nconst ki = /* @__PURE__ */ Lt({\n  __name: \"QrcodeStream\",\n  props: {\n    // in this file: don't use `props.constraints` directly. Use `constraintsCached`.\n    constraints: {\n      type: Object,\n      default() {\n        return { facingMode: \"environment\" };\n      }\n    },\n    // in this file: don't use `props.formats` directly. Use `formatsCached`.\n    formats: {\n      type: Array,\n      default: () => [\"qr_code\"]\n    },\n    paused: {\n      type: Boolean,\n      default: !1\n    },\n    torch: {\n      type: Boolean,\n      default: !1\n    },\n    track: {\n      type: Function\n    }\n  },\n  emits: [\"detect\", \"camera-on\", \"camera-off\", \"error\"],\n  setup(r, { emit: o }) {\n    const i = r, c = o, d = we(i.constraints), h = we(i.formats);\n    We(\n      () => i.constraints,\n      (k, M) => {\n        JSON.stringify(k) !== JSON.stringify(M) && (d.value = k);\n      },\n      { deep: !0 }\n    ), We(\n      () => i.formats,\n      (k, M) => {\n        JSON.stringify(k) !== JSON.stringify(M) && (h.value = k);\n      },\n      { deep: !0 }\n    );\n    const v = we(), g = we(), b = we(), p = we(!1), C = we(!1);\n    po(() => {\n      C.value = !0;\n    }), mo(() => {\n      ot();\n    });\n    const S = Ut(() => ({\n      torch: i.torch,\n      constraints: d.value,\n      shouldStream: C.value && !i.paused\n    }));\n    We(\n      S,\n      async (k) => {\n        const M = b.value;\n        ue(\n          M !== void 0,\n          \"cameraSettings watcher should never be triggered when component is not mounted. Thus video element should always be defined.\"\n        );\n        const A = v.value;\n        ue(\n          A !== void 0,\n          \"cameraSettings watcher should never be triggered when component is not mounted. Thus canvas should always be defined.\"\n        );\n        const le = A.getContext(\"2d\");\n        if (ue(le !== null, \"if cavnas is defined, canvas 2d context should also be non-null\"), k.shouldStream) {\n          ot(), p.value = !1;\n          try {\n            const oe = await xi(M, k);\n            C.value ? (p.value = !0, c(\"camera-on\", oe)) : await ot();\n          } catch (oe) {\n            c(\"error\", oe);\n          }\n        } else\n          A.width = M.videoWidth, A.height = M.videoHeight, le.drawImage(M, 0, 0, M.videoWidth, M.videoHeight), ot(), p.value = !1, c(\"camera-off\");\n      },\n      { deep: !0 }\n    ), We(h, (k) => {\n      C.value && Zo(k);\n    });\n    const $ = Ut(() => S.value.shouldStream && p.value);\n    We($, (k) => {\n      if (k) {\n        ue(\n          v.value !== void 0,\n          \"shouldScan watcher should only be triggered when component is mounted. Thus pause frame canvas is defined\"\n        ), F(v.value), ue(\n          g.value !== void 0,\n          \"shouldScan watcher should only be triggered when component is mounted. Thus tracking canvas is defined\"\n        ), F(g.value);\n        const M = () => i.track === void 0 ? 500 : 40;\n        ue(\n          b.value !== void 0,\n          \"shouldScan watcher should only be triggered when component is mounted. Thus video element is defined\"\n        ), Ko(b.value, {\n          detectHandler: (A) => c(\"detect\", A),\n          formats: h.value,\n          locateHandler: U,\n          minDelay: M()\n        });\n      }\n    });\n    const F = (k) => {\n      const M = k.getContext(\"2d\");\n      ue(M !== null, \"canvas 2d context should always be non-null\"), M.clearRect(0, 0, k.width, k.height);\n    }, U = (k) => {\n      const M = g.value;\n      ue(\n        M !== void 0,\n        \"onLocate handler should only be called when component is mounted. Thus tracking canvas is always defined.\"\n      );\n      const A = b.value;\n      if (ue(\n        A !== void 0,\n        \"onLocate handler should only be called when component is mounted. Thus video element is always defined.\"\n      ), k.length === 0 || i.track === void 0)\n        F(M);\n      else {\n        const le = A.offsetWidth, oe = A.offsetHeight, be = A.videoWidth, Ce = A.videoHeight, Oe = Math.max(le / be, oe / Ce), Me = be * Oe, Le = Ce * Oe, dt = Me / be, ft = Le / Ce, ht = (le - Me) / 2, pt = (oe - Le) / 2, Ae = ({ x: de, y: Z }) => ({\n          x: Math.floor(de * dt),\n          y: Math.floor(Z * ft)\n        }), te = ({ x: de, y: Z }) => ({\n          x: Math.floor(de + ht),\n          y: Math.floor(Z + pt)\n        }), ve = k.map((de) => {\n          const { boundingBox: Z, cornerPoints: vt } = de, { x: He, y: fe } = te(\n            Ae({\n              x: Z.x,\n              y: Z.y\n            })\n          ), { x: Be, y: yt } = Ae({\n            x: Z.width,\n            y: Z.height\n          });\n          return {\n            ...de,\n            cornerPoints: vt.map((Ve) => te(Ae(Ve))),\n            boundingBox: DOMRectReadOnly.fromRect({ x: He, y: fe, width: Be, height: yt })\n          };\n        });\n        M.width = A.offsetWidth, M.height = A.offsetHeight;\n        const mt = M.getContext(\"2d\");\n        i.track(ve, mt);\n      }\n    }, W = {\n      width: \"100%\",\n      height: \"100%\",\n      position: \"relative\",\n      // notice that we use z-index only once for the wrapper div.\n      // If z-index is not defined, elements are stacked in the order they appear in the DOM.\n      // The first element is at the very bottom and subsequent elements are added on top.\n      \"z-index\": \"0\"\n    }, x = {\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      top: \"0\",\n      left: \"0\"\n    }, D = {\n      width: \"100%\",\n      height: \"100%\",\n      \"object-fit\": \"cover\"\n    }, X = Ut(() => $.value ? D : {\n      ...D,\n      visibility: \"hidden\",\n      position: \"absolute\"\n    });\n    return (k, M) => (Ht(), Bt(\"div\", { style: W }, [\n      nt(\"video\", {\n        ref_key: \"videoRef\",\n        ref: b,\n        style: vo(X.value),\n        autoplay: \"\",\n        muted: \"\",\n        playsinline: \"\"\n      }, null, 4),\n      yo(nt(\"canvas\", {\n        id: \"qrcode-stream-pause-frame\",\n        ref_key: \"pauseFrameRef\",\n        ref: v,\n        style: D\n      }, null, 512), [\n        [go, !$.value]\n      ]),\n      nt(\"canvas\", {\n        id: \"qrcode-stream-tracking-layer\",\n        ref_key: \"trackingLayerRef\",\n        ref: g,\n        style: x\n      }, null, 512),\n      nt(\"div\", { style: x }, [\n        Mr(k.$slots, \"default\")\n      ])\n    ]));\n  }\n}), Ii = /* @__PURE__ */ Lt({\n  __name: \"QrcodeCapture\",\n  props: {\n    formats: {\n      type: Array,\n      default: () => [\"qr_code\"]\n    }\n  },\n  emits: [\"detect\"],\n  setup(r, { emit: o }) {\n    const i = r, c = o, d = (h) => {\n      if (!(!(h.target instanceof HTMLInputElement) || !h.target.files))\n        for (const v of Array.from(h.target.files))\n          Nr(v, i.formats).then((g) => {\n            c(\"detect\", g);\n          });\n    };\n    return (h, v) => (Ht(), Bt(\"input\", {\n      onChange: d,\n      type: \"file\",\n      name: \"image\",\n      accept: \"image/*\",\n      capture: \"environment\",\n      multiple: \"\"\n    }, null, 32));\n  }\n}), Fi = /* @__PURE__ */ Lt({\n  __name: \"QrcodeDropZone\",\n  props: {\n    formats: {\n      type: Array,\n      default: () => [\"qr_code\"]\n    }\n  },\n  emits: [\"detect\", \"dragover\", \"error\"],\n  setup(r, { emit: o }) {\n    const i = r, c = o, d = async (g) => {\n      try {\n        const b = await g;\n        c(\"detect\", b);\n      } catch (b) {\n        c(\"error\", b);\n      }\n    }, h = (g) => {\n      c(\"dragover\", g);\n    }, v = ({ dataTransfer: g }) => {\n      if (!g)\n        return;\n      h(!1);\n      const b = [...Array.from(g.files)], p = g.getData(\"text/uri-list\");\n      b.forEach((C) => {\n        d(Nr(C));\n      }), p !== \"\" && d(ti(p, i.formats));\n    };\n    return (g, b) => (Ht(), Bt(\"div\", {\n      onDrop: at(v, [\"prevent\", \"stop\"]),\n      onDragenter: b[0] || (b[0] = at((p) => h(!0), [\"prevent\", \"stop\"])),\n      onDragleave: b[1] || (b[1] = at((p) => h(!1), [\"prevent\", \"stop\"])),\n      onDragover: b[2] || (b[2] = at(() => {\n      }, [\"prevent\", \"stop\"]))\n    }, [\n      Mr(g.$slots, \"default\")\n    ], 32));\n  }\n});\nfunction Ui(r) {\n  r.component(\"qrcode-stream\", ki), r.component(\"qrcode-capture\", Ii), r.component(\"qrcode-drop-zone\", Fi);\n}\nconst Li = { install: Ui };\nexport {\n  Ii as QrcodeCapture,\n  Fi as QrcodeDropZone,\n  ki as QrcodeStream,\n  Li as VueQrcodeReader,\n  Ui as install,\n  ji as setZXingModuleOverrides\n};\n",
      "start": 1751024557695,
      "end": 1751024557959,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1751024557960,
      "end": 1751024557960,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1751024557960,
      "end": 1751024557961,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1751024557961,
      "end": 1751024557973,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1751024557973,
      "end": 1751024557973,
      "order": "normal"
    }
  ]
}
